<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tablero 12x10</title>
  <style>
    :root {
      --square-size: 70px;
      --board-columns: 12;
      --board-rows: 10;
      --board-width: calc(var(--square-size) * var(--board-columns));
      --board-height: calc(var(--square-size) * var(--board-rows));
      --board-color: #1f8a3b;
      --square-border: #0f4d20;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, #0f4d20 0%, #0d3618 100%);
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      color: #f4f4f4;
    }

    .wrapper {
      text-align: center;
      max-width: 1400px;
      padding: 24px 18px 40px;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-bottom: 16px;
    }

    .button {
      background: #f4f4f4;
      color: #0d3618;
      border: none;
      border-radius: 8px;
      padding: 10px 16px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
    }

    .button:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      background: #ffffff;
    }

    .button:active {
      transform: translateY(0);
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.28);
    }

    .button--primary {
      background: #f17c00;
      color: #fff8f0;
    }

    .button--primary:hover {
      background: #ff9400;
    }

    .button--pulse {
      animation: pulse 0.8s ease-in-out infinite;
      box-shadow: 0 0 0 0 rgba(241, 124, 0, 0.65);
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(241, 124, 0, 0.65);
      }
      70% {
        box-shadow: 0 0 0 12px rgba(241, 124, 0, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(241, 124, 0, 0);
      }
    }

    .board {
      width: calc(var(--board-width) + 16px);
      height: calc(var(--board-height) + 16px);
      display: grid;
      grid-template-columns: repeat(var(--board-columns), var(--square-size));
      grid-template-rows: repeat(var(--board-rows), var(--square-size));
      background-color: var(--board-color);
      border: 8px solid #0b2a13;
      border-radius: 12px;
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
      overflow: hidden;
      box-sizing: content-box;
      justify-self: center;
    }

    .square {
      position: relative;
      width: var(--square-size);
      height: var(--square-size);
      border: 1px solid var(--square-border);
      background-color: var(--board-color);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .piece {
      position: absolute;
      width: 80%;
      height: 80%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
      border: 3px solid rgba(255, 255, 255, 0.3);
      display: grid;
      place-items: center;
      background: #0d0d0d;
      overflow: hidden;
      z-index: 3;
    }

    .piece__image {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .piece__name {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .piece--active {
      outline: 4px solid #fbd34d;
      outline-offset: 1px;
      box-shadow: 0 0 0 5px rgba(251, 211, 77, 0.4);
      animation: blink 1s ease-in-out infinite alternate;
    }

    @keyframes blink {
      from {
        filter: brightness(1);
      }
      to {
        filter: brightness(1.25);
      }
    }

    .square::before,
    .square::after {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 120ms ease;
    }

    .square::before {
      z-index: 1;
    }

    .square::after {
      z-index: 2;
    }

    .square--range::after {
      opacity: 1;
      box-shadow: inset 0 0 0 5px rgba(255, 132, 0, 0.45);
      background: radial-gradient(circle at 50% 50%, rgba(255, 132, 0, 0.28), transparent 65%);
    }

    .square--target {
      box-shadow: inset 0 0 0 4px rgba(255, 171, 64, 0.9), inset 0 0 0 7px rgba(255, 171, 64, 0.35);
    }

    .square--move::before {
      opacity: 1;
      box-shadow: inset 0 0 0 4px rgba(0, 0, 0, 0.45);
      background: radial-gradient(circle at 50% 50%, rgba(0, 0, 0, 0.28), transparent 70%);
    }

    .tooltip {
      position: fixed;
      top: 0;
      left: 0;
      transform: none;
      background: #0f4d20;
      color: #f4f4f4;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 14px 16px;
      box-shadow: 0 16px 32px rgba(0, 0, 0, 0.4);
      pointer-events: none;
      white-space: nowrap;
      font-size: 0.95rem;
      z-index: 20;
      min-width: 240px;
      max-width: 320px;
    }

    .tooltip h3 {
      margin: 0 0 6px;
      font-size: 1rem;
    }

    .tooltip ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 4px 8px;
    }

    .layout {
      display: grid;
      grid-template-columns: 340px auto 340px;
      gap: 16px;
      align-items: center;
    }

    .turn-popup,
    .death-popup {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.45);
      z-index: 30;
    }

    .turn-popup[hidden],
    .death-popup[hidden] {
      display: none;
    }

    .turn-popup__content,
    .death-popup__content {
      background: #0f4d20;
      border: 2px solid rgba(255, 255, 255, 0.35);
      border-radius: 14px;
      padding: 18px 20px;
      max-width: 480px;
      box-shadow: 0 20px 36px rgba(0, 0, 0, 0.45);
      text-align: center;
    }

    .turn-popup__message,
    .death-popup__message {
      margin: 0 0 8px;
      font-size: 1.05rem;
      line-height: 1.4;
    }

    .turn-popup__hint {
      margin: 0;
      font-size: 0.9rem;
      opacity: 0.85;
    }

    .card-panel {
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
    }

    .card-panel h3 {
      margin: 0 0 8px;
      font-size: 1rem;
      letter-spacing: 0.02em;
    }

    .card-panel__content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items: flex-start;
    }

    .life-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .life-card {
      display: grid;
      grid-template-columns: 1fr auto;
      grid-template-rows: auto auto;
      gap: 4px 10px;
      align-items: center;
      background: rgba(15, 77, 32, 0.65);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 700;
      color: #f4f4f4;
      text-align: left;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08);
    }

    .life-card__main {
      display: flex;
      align-items: center;
      gap: 8px;
      grid-column: 1 / 2;
    }

    .life-card__avatar {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      object-fit: cover;
      border: 1px solid rgba(255, 255, 255, 0.35);
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
      background: #0d0d0d;
    }

    .life-card__label {
      display: block;
      line-height: 1.2;
    }

    .life-value {
      font-variant-numeric: tabular-nums;
      grid-column: 1 / span 2;
    }

    .life-points {
      justify-self: end;
      font-size: 0.92rem;
      opacity: 0.95;
      grid-column: 2 / 3;
      grid-row: 1;
    }

    .status-bar {
      margin-bottom: 12px;
      display: flex;
      justify-content: center;
      gap: 16px;
      align-items: center;
      font-weight: 700;
    }

    .piece--incapacitated::after {
      content: '✖';
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(255, 0, 0, 0.35);
      color: #fff;
      font-size: 42px;
      font-weight: 900;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <main class="wrapper">
    <div class="controls" aria-label="Controles de turno">
      <button class="button" id="passTurn" type="button">Pasar</button>
      <button class="button button--primary" id="attack" type="button">Atacar</button>
    </div>
    <div class="controls" id="powerControls" aria-label="Poderes activos"></div>
    <div class="status-bar" aria-live="polite">
      <span id="turnInfo">Turno:</span>
      <span id="movementInfo"></span>
    </div>
    <div id="combatInfo" aria-live="polite" style="margin-bottom: 12px; font-weight: 700;"></div>

    <div class="layout">
      <aside class="card-panel" aria-label="Vida aliados">
        <h3>Aliados</h3>
        <div class="card-panel__content">
          <div class="life-list" id="allyCards"></div>
        </div>
      </aside>
      <section class="board" aria-label="Tablero de 120 cuadros verdes"></section>
      <aside class="card-panel" aria-label="Vida enemigos">
        <h3>Enemigos</h3>
        <div class="card-panel__content">
          <div class="life-list" id="enemyCards"></div>
        </div>
      </aside>
    </div>
  </main>
  <div id="tooltip" class="tooltip" hidden></div>
  <div id="turnPopup" class="turn-popup" hidden>
    <div class="turn-popup__content">
      <p id="turnPopupMessage" class="turn-popup__message"></p>
      <p class="turn-popup__hint">Pulsa cualquier tecla o botón para continuar</p>
    </div>
  </div>
  <div id="deathPopup" class="death-popup" hidden>
    <div class="death-popup__content">
      <p id="deathPopupMessage" class="death-popup__message"></p>
      <p class="turn-popup__hint">Pulsa cualquier tecla o botón para continuar</p>
    </div>
  </div>

    <script src="js/poderes.js"></script>
    <script src="js/personajes.js"></script>
    <script>
      const board = document.querySelector('.board');
      const pieceStats =
        (typeof personajes !== 'undefined' && personajes) ||
        (typeof window !== 'undefined' ? window.personajes : {});
      const SCORE_PER_DAMAGE = 10;
      const SCORE_PER_KILL = 50;
      const punchSound = new Audio('sonido/Punch.mp3');
      const failureSound = new Audio('sonido/Failure.mp3');
      const incapacitarSound = new Audio('sonido/incapacitar.wav');
      const passTurnSound = new Audio('sonido/pasar.wav');
      const explosionSound = new Audio('sonido/explosion.mp3');
      const deathSound = new Audio('sonido/muerte.wav');
      let pendingPopupSound = null;
      const BOARD_ROWS = 10;
      const BOARD_COLS = 12;
      const backgroundMusic = new Audio('sonido/Endgame.mp3');
      backgroundMusic.loop = true;
      backgroundMusic.volume = 0.35;
      let backgroundStarted = false;

      const HULK_KEY = 'hulk';
      const HULK_ANIMATIONS = {
        activo: 'imagenes/hulk.webp',
        espera: 'imagenes/hulk.webp',
        andar: 'imagenes/hulk.webp',
      };

      function findHulkPiece() {
        return Array.from(board.querySelectorAll('.piece')).find((piece) => piece.dataset.key === HULK_KEY);
      }

      function setHulkAnimation(state) {
        const animation = HULK_ANIMATIONS[state];
        if (!animation) return;
        const hulkPiece = findHulkPiece();
        if (!hulkPiece) return;
        const img = hulkPiece.querySelector('.piece__image');
        if (!img) return;
        if (hulkPiece.dataset.animationState === state && img.getAttribute('src') === animation) return;
        img.src = animation;
        hulkPiece.dataset.animationState = state;
      }

    const initialPositions = [
      { key: 'avispa', team: 'aliado', row: 1, col: 1, className: 'piece--white' },
      { key: 'hulk', team: 'aliado', row: 2, col: 1, className: 'piece--red' },
      { key: 'capitan', team: 'aliado', row: 3, col: 1, className: 'piece--violet' },
      { key: 'spider', team: 'aliado', row: 4, col: 1, className: 'piece--blue' },
      { key: 'lobezno', team: 'aliado', row: 5, col: 1, className: 'piece--gold' },
      { key: 'ciclope', team: 'aliado', row: 6, col: 1, className: 'piece--white' },
      { key: 'cosa', team: 'aliado', row: 7, col: 1, className: 'piece--red' },
      { key: 'antorcha', team: 'aliado', row: 8, col: 1, className: 'piece--gold' },
      { key: 'duende', team: 'enemigo', row: 1, col: 12, className: 'piece--black' },
      { key: 'chaquetaAmarilla', team: 'enemigo', row: 2, col: 12, className: 'piece--black' },
      { key: 'dientesDeSable', team: 'enemigo', row: 3, col: 12, className: 'piece--black' },
      { key: 'boomerang', team: 'enemigo', row: 4, col: 12, className: 'piece--black' },
      { key: 'juggernaut', team: 'enemigo', row: 5, col: 12, className: 'piece--black' },
      { key: 'mole', team: 'enemigo', row: 6, col: 12, className: 'piece--black' },
      { key: 'doom', team: 'enemigo', row: 7, col: 12, className: 'piece--black' },
      { key: 'ultron', team: 'enemigo', row: 8, col: 12, className: 'piece--black' },
    ];

    function createPieceElement({ key, team, className }) {
      const stats = pieceStats[key];
      const piece = document.createElement('span');
      piece.className = `piece ${className}`;
      piece.dataset.team = team;
      piece.dataset.key = key;
      piece.setAttribute('role', 'img');
      piece.setAttribute('aria-label', stats?.name || key);
      piece.innerHTML = `
        <img class="piece__image" src="${stats?.imagen || ''}" alt="${stats?.name || key}" />
        <span class="piece__name">${stats?.name || key}</span>
      `;
      return piece;
    }

    function buildBoard() {
      board.innerHTML = '';
      for (let row = 1; row <= BOARD_ROWS; row += 1) {
        for (let col = 1; col <= BOARD_COLS; col += 1) {
          const square = document.createElement('div');
          square.className = 'square';
          const occupant = initialPositions.find((item) => item.row === row && item.col === col);
          if (occupant) {
            square.appendChild(createPieceElement(occupant));
          }
          board.appendChild(square);
        }
      }
    }

    buildBoard();
    setHulkAnimation('espera');

    const squares = Array.from(board.querySelectorAll('.square'));
    const tooltip = document.getElementById('tooltip');
    const turnPopup = document.getElementById('turnPopup');
    const turnPopupMessage = document.getElementById('turnPopupMessage');
    const deathPopup = document.getElementById('deathPopup');
    const deathPopupMessage = document.getElementById('deathPopupMessage');
    const passButton = document.getElementById('passTurn');
    const attackButton = document.getElementById('attack');
    const powerControls = document.getElementById('powerControls');
    const turnInfo = document.getElementById('turnInfo');
    const movementInfo = document.getElementById('movementInfo');
    const allyCards = document.getElementById('allyCards');
    const enemyCards = document.getElementById('enemyCards');

    const AI_DELAY_MS = 900;
    const TURN_DELAY_MS = 250;
    const ENEMY_ACTION_DELAY_MS = 500;
    const DEFAULT_MOVE_DURATION_MS = 1200;

    const squaresByCoord = new Map();
    squares.forEach((square, index) => {
      const row = Math.floor(index / BOARD_COLS) + 1;
      const col = (index % BOARD_COLS) + 1;
      square.dataset.row = row;
      square.dataset.col = col;
      squaresByCoord.set(`${row},${col}`, square);
    });

    const pieceMap = new Map();
    let movementDistances = new Map();
    let currentAction = 'attack';
    let movementAnimationDuration = DEFAULT_MOVE_DURATION_MS;

    function hasPassive(stats, key) {
      return Boolean(stats?.habilidades?.pasivas?.includes(key));
    }

    function hasActive(stats, key) {
      return Boolean(stats?.habilidades?.activas?.includes(key));
    }

    function pieceColor(element) {
      if (element.classList.contains('piece--white')) return '#dcdcdc';
      if (element.classList.contains('piece--red')) return '#c62828';
      if (element.classList.contains('piece--violet')) return '#8e44ad';
      if (element.classList.contains('piece--blue')) return '#1e88e5';
      if (element.classList.contains('piece--gold')) return '#f4a300';
      return '#1f1f1f';
    }

    function addPoints(piece, amount) {
      const stats = pieceMap.get(piece);
      if (!stats || !Number.isFinite(amount)) return;
      stats.puntos = (stats.puntos || 0) + amount;
    }

    function isEnemy(attacker, target) {
      return attacker?.dataset.team && target?.dataset.team && attacker.dataset.team !== target.dataset.team;
    }

    function registerTurnSound({ damageDealt = 0, attackFailed = false } = {}) {
      if (damageDealt > 0) {
        pendingPopupSound = 'punch';
        return;
      }
      if (attackFailed && !pendingPopupSound) {
        pendingPopupSound = 'failure';
      }
    }

    function playTurnSound() {
      const chosen = pendingPopupSound;
      pendingPopupSound = null;
      const sound = chosen === 'punch' ? punchSound : chosen === 'failure' ? failureSound : null;
      if (!sound) return;
      sound.currentTime = 0;
      sound.play().catch(() => {});
    }

    function playEffectSound(sound) {
      if (!sound) return;
      sound.currentTime = 0;
      sound.play().catch(() => {});
    }

    function startBackgroundMusic() {
      if (backgroundStarted) return;
      backgroundStarted = true;
      backgroundMusic.currentTime = 0;
      backgroundMusic.play().catch(() => {
        backgroundStarted = false;
      });
    }

    function attachPieceData(piece, key, team) {
      const stats = pieceStats[key];
      if (!stats) return;
      const abilities = stats.habilidades || { activas: [], pasivas: [] };
      const computedStats = {
        ...stats,
        habilidades: abilities,
        currentVida: stats.vida,
        maxVida: stats.vida,
        incapacitatedTurns: 0,
        puntos: 0,
      };
      piece.dataset.key = key;
      piece.dataset.team = team;
      piece.dataset.rango = stats.rango;
      piece.dataset.movimiento = stats.movimiento;
      piece.dataset.stats = JSON.stringify(computedStats);
      pieceMap.set(piece, computedStats);
    }

    const pieces = Array.from(board.querySelectorAll('.piece')).map((element) => ({
      element,
      key: element.dataset.key,
      team: element.dataset.team,
    }));

    pieces.forEach(({ element, key, team }) => {
      if (element) {
        attachPieceData(element, key, team);
      }
    });

    function renderLifeCards() {
      allyCards.innerHTML = '';
      enemyCards.innerHTML = '';

      pieces.forEach(({ element }) => {
        if (!element || element.dataset.eliminated === 'true') return;
        const stats = pieceMap.get(element);
        const container = element.dataset.team === 'aliado' ? allyCards : enemyCards;
        const card = document.createElement('div');
        card.className = 'life-card';
        card.innerHTML = `
          <div class="life-card__main">
            <img class="life-card__avatar" src="${stats.imagen}" alt="${stats.name}" loading="lazy" />
            <span class="life-card__label">${stats.name}</span>
          </div>
          <span class="life-value">Vida: ${Math.max(stats.currentVida, 0)}</span>
          <span class="life-points">${stats.puntos ?? 0} pts</span>
        `;
        container.appendChild(card);
      });
    }

    renderLifeCards();

    function addHistoryEntry(team, message, options = {}) {
      const { preserveLatest = false } = options;
      if (!preserveLatest) {
        latestActionMessage = message;
      }
    }

    function hideTurnPopup() {
      turnPopup.hidden = true;
    }

    function showTurnPopup(message) {
      return new Promise((resolve) => {
        resolveTurnPopup = () => {
          hideTurnPopup();
          resolve();
        };
        turnPopupMessage.textContent = message || 'Turno completado.';
        turnPopup.hidden = false;
        playTurnSound();
      });
    }

    function hideDeathPopup() {
      deathPopup.hidden = true;
    }

    function showDeathPopup(message) {
      return new Promise((resolve) => {
        resolveDeathPopup = () => {
          hideDeathPopup();
          resolve();
        };
        deathPopupMessage.textContent = message || 'Un personaje ha caído.';
        deathPopup.hidden = false;
      });
    }

    function handleTurnPopupDismiss() {
      if (turnPopup.hidden || !resolveTurnPopup) return;
      playTurnSound();
      const resolver = resolveTurnPopup;
      resolveTurnPopup = null;
      resolver();
    }

    function handleDeathPopupDismiss() {
      if (deathPopup.hidden || !resolveDeathPopup) return;
      const resolver = resolveDeathPopup;
      resolveDeathPopup = null;
      resolver();
    }

    function handleGlobalDismiss() {
      handleDeathPopupDismiss();
      handleTurnPopupDismiss();
    }

    ['keydown', 'mousedown', 'mouseup', 'touchstart'].forEach((eventName) => {
      document.addEventListener(eventName, (event) => {
        startBackgroundMusic();
        handleGlobalDismiss(event);
      });
    });

    function renderPowerButtons(piece) {
      powerControls.innerHTML = '';
      const stats = pieceMap.get(piece);
      if (!stats) return;
      const actives = stats.habilidades?.activas || [];
      actives.forEach((ability) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'button';
        const labels = {
          incapacitar: 'Incapacitar',
          explosion: 'Explosión',
          pulso: 'Pulso',
        };
        btn.textContent = labels[ability] || ability;
        btn.disabled = piece.dataset.team === 'enemigo';
        btn.addEventListener('click', () => handleActionClick(ability));
        powerControls.appendChild(btn);
      });
    }

    const turnOrder = pieces
      .map(({ element }) => element)
      .filter(Boolean)
      .sort((a, b) => {
        const statsA = pieceMap.get(a);
        const statsB = pieceMap.get(b);
        if (statsA.agilidad === statsB.agilidad) {
          return Math.random() < 0.5 ? -1 : 1;
        }
        return statsB.agilidad - statsA.agilidad;
      });

    let turnIndex = 0;
    let selectedTarget = null;
    let pendingAttackInfo = null;
    let latestActionMessage = null;
    let resolveTurnPopup = null;
    let resolveDeathPopup = null;
    const pendingDeathMessages = [];

    function getPieceSquare(piece) {
      return piece.closest('.square');
    }

    function getSquareAt(row, col) {
      return squaresByCoord.get(`${row},${col}`);
    }

    function computeReachableSquares(piece) {
      const origin = getPieceSquare(piece);
      if (!origin) return;
      const maxMove = remainingMovement(piece);
      const visited = new Map();
      const queue = [{ row: Number(origin.dataset.row), col: Number(origin.dataset.col), cost: 0 }];
      visited.set(`${origin.dataset.row},${origin.dataset.col}`, 0);

      const deltas = [
        [1, 0],
        [-1, 0],
        [0, 1],
        [0, -1],
      ];

      while (queue.length) {
        const { row, col, cost } = queue.shift();
        for (const [dr, dc] of deltas) {
          const nr = row + dr;
          const nc = col + dc;
          const key = `${nr},${nc}`;
          if (nr < 1 || nr > BOARD_ROWS || nc < 1 || nc > BOARD_COLS) continue;
          const nextCost = cost + 1;
          if (nextCost > maxMove) continue;
          if (visited.has(key) && visited.get(key) <= nextCost) continue;
          const square = getSquareAt(nr, nc);
          if (!square) continue;
          const occupant = square.querySelector('.piece');
          if (occupant && occupant.dataset.team !== piece.dataset.team) continue;
          visited.set(key, nextCost);
          queue.push({ row: nr, col: nc, cost: nextCost });
        }
      }

      movementDistances = new Map();
      visited.forEach((dist, key) => {
        const square = squaresByCoord.get(key);
        if (!square) return;
        const occupied = square.querySelector('.piece');
        if (!occupied && dist > 0) {
          movementDistances.set(square, dist);
        }
      });
    }

    function clearMoveHighlights() {
      squares.forEach((square) => square.classList.remove('square--move'));
    }

    function clearRangeHighlights() {
      squares.forEach((square) => square.classList.remove('square--range', 'square--target'));
    }

    function clearHighlights() {
      clearMoveHighlights();
      clearRangeHighlights();
      tooltip.hidden = true;
      selectedTarget = null;
    }

    function highlightMovement(piece) {
      computeReachableSquares(piece);
      if (movementDistances.size === 0) return;
      movementDistances.forEach((_, square) => {
        square.classList.add('square--move');
      });
    }

    function isWithinAttackRange(attackerSquare, targetSquare, maxRange) {
      const attackerRow = Number(attackerSquare.dataset.row);
      const attackerCol = Number(attackerSquare.dataset.col);
      const targetRow = Number(targetSquare.dataset.row);
      const targetCol = Number(targetSquare.dataset.col);
      const distance = Math.abs(targetRow - attackerRow) + Math.abs(targetCol - attackerCol);
      return distance > 0 && distance <= maxRange;
    }

    function highlightRange(piece) {
      clearRangeHighlights();
      const origin = getPieceSquare(piece);
      if (!origin) return;
      const maxRange = rangeForPiece(piece);
      if (maxRange <= 0) return;
      squares.forEach((square) => {
        if (isWithinAttackRange(origin, square, maxRange)) {
          square.classList.add('square--range');
        }
      });
    }

    function setActivePiece(piece) {
      document.querySelectorAll('.piece').forEach((p) => p.classList.remove('piece--active'));
      piece.classList.add('piece--active');
      if (piece.dataset.key === HULK_KEY) {
        setHulkAnimation('activo');
      } else {
        setHulkAnimation('espera');
      }
      const isEnemyTurn = piece.dataset.team === 'enemigo';
      passButton.disabled = isEnemyTurn;
      attackButton.disabled = isEnemyTurn;
      updateStatusBar(piece);
      updateCombatInfo();
      currentAction = 'attack';
      renderPowerButtons(piece);
    }

    function updateStatusBar(piece) {
      const stats = pieceMap.get(piece);
      if (!stats) return;
      turnInfo.textContent = `Turno: ${stats.name}`;
      movementInfo.textContent = `Movimiento restante: ${remainingMovement(piece)}`;
    }

    function attackDistance(attackerSquare, targetSquare) {
      return (
        Math.abs(Number(attackerSquare.dataset.row) - Number(targetSquare.dataset.row)) +
        Math.abs(Number(attackerSquare.dataset.col) - Number(targetSquare.dataset.col))
      );
    }

    function effectiveRangeFromStats(stats) {
      const raw = Number(stats?.rango ?? 0);
      return raw === 0 ? 1 : raw;
    }

    function calculateDamage(attackerStats, defenderStats, distance, isCritical) {
      const isMelee = distance <= 1;
      let baseDamage = isMelee ? attackerStats.danoCC : attackerStats.danoAD;
      let clawsRoll = null;
      if (isMelee && hasPassive(attackerStats, 'garras')) {
        clawsRoll = Math.floor(Math.random() * 6) + 1;
        baseDamage = Math.max(baseDamage, clawsRoll);
      }
      const resistance = isMelee ? defenderStats.resistenciaCC : defenderStats.resistenciaAD;
      const rawDamage = isCritical ? baseDamage * 2 : baseDamage;
      const totalDamage = Math.max(rawDamage - resistance, 0);
      return { totalDamage, isMelee, clawsRoll, rawDamage };
    }

    function evaluateAttackRoll(attackerStats, defenderStats, roll, distance, options = {}) {
      const { allowCounter = false } = options;
      const hasAstucia = hasPassive(attackerStats, 'astucia');
      const critical = hasAstucia ? roll >= 11 : roll === 12;
      const isPifia = roll === 2;
      const isMelee = distance <= 1;
      const defenderCanRanged = effectiveRangeFromStats(defenderStats) > 1;

      let success = false;

      if (critical) {
        success = true;
      } else if (isPifia) {
        if (isMelee || defenderCanRanged) {
          success = roll + attackerStats.ataque >= defenderStats.defensa;
        } else {
          success = false;
        }
      } else {
        success = roll + attackerStats.ataque >= defenderStats.defensa;
      }

      const shouldCounter = allowCounter && isPifia && (isMelee || defenderCanRanged);

      return { success, critical, isPifia, shouldCounter };
    }

    function queueDeathMessage(message) {
      pendingDeathMessages.push(message);
    }

    async function showQueuedDeathPopups() {
      while (pendingDeathMessages.length > 0) {
        const message = pendingDeathMessages.shift();
        // eslint-disable-next-line no-await-in-loop
        await showDeathPopup(message);
      }
    }

    function eliminatePiece(piece) {
      if (!piece || piece.dataset.eliminated === 'true') return;
      playEffectSound(deathSound);
      const index = turnOrder.indexOf(piece);
      if (index !== -1) {
        turnOrder.splice(index, 1);
        if (index <= turnIndex && turnIndex > 0) {
          turnIndex -= 1;
        }
      }
      piece.dataset.eliminated = 'true';
      piece.remove();
    }

    function rangeForPiece(piece) {
      const r = parseInt(piece.dataset.rango, 10);
      return r === 0 ? 1 : r;
    }

    function showTooltip(piece) {
      const stats = pieceMap.get(piece);
      if (!stats) return;
      tooltip.innerHTML = `
        <h3>${stats.name}</h3>
        <ul>
          <li>Mov: ${stats.movimiento}</li>
          <li>Atk: ${stats.ataque}</li>
          <li>Def: ${stats.defensa}</li>
          <li>C/C: ${stats.danoCC}</li>
          <li>A/D: ${stats.danoAD}</li>
          <li>Res C/C: ${stats.resistenciaCC}</li>
          <li>Res A/D: ${stats.resistenciaAD}</li>
          <li>Rango: ${stats.rango}</li>
          <li>Vida: ${Math.max(stats.currentVida, 0)}</li>
          <li>Agilidad: ${stats.agilidad}</li>
        </ul>
      `;
      tooltip.hidden = false;
      requestAnimationFrame(() => positionTooltip(piece));
    }

    function positionTooltip(target) {
      const targetRect = target.getBoundingClientRect();
      const tooltipRect = tooltip.getBoundingClientRect();
      const offset = 12;
      const padding = 8;
      let left = targetRect.right + offset;
      let top = targetRect.top + targetRect.height / 2 - tooltipRect.height / 2;

      if (left + tooltipRect.width > window.innerWidth - padding) {
        left = targetRect.left - tooltipRect.width - offset;
      }

      left = Math.max(padding, Math.min(left, window.innerWidth - tooltipRect.width - padding));
      top = Math.max(padding, Math.min(top, window.innerHeight - tooltipRect.height - padding));

      tooltip.style.left = `${left}px`;
      tooltip.style.top = `${top}px`;
    }

    function hideTooltip() {
      tooltip.hidden = true;
    }

    function setIncapacitated(piece, turns = 1) {
      const stats = pieceMap.get(piece);
      if (!stats) return;
      stats.incapacitatedTurns = turns;
      piece.classList.add('piece--incapacitated');
    }

    function actionLabel(actionKey) {
      if (actionKey === 'incapacitar') return 'Incapacitar';
      if (actionKey === 'explosion') return 'Explosión';
      if (actionKey === 'pulso') return 'Pulso';
      return 'Ataque';
    }

    function updateCombatInfo() {
      const combatBox = document.getElementById('combatInfo');
      if (!pendingAttackInfo) {
        combatBox.textContent = '';
        return;
      }
      const info = pendingAttackInfo;
      if (info.targets) {
        const summary = info.targets
          .map((target) => {
            const base = `${target.name}: ${target.success ? 'Éxito' : 'Fallo'}`;
            const damageText = target.success ? ` | Daño ${target.damage} (Vida ${target.vida})` : '';
            return `${base}${damageText}`;
          })
          .join(' | ');
        combatBox.textContent = `${info.action} de ${info.attackerName} | Tirada 2d6: ${info.roll}${
          info.critical ? ' (Crítico)' : ''
        } | ${summary}`;
        return;
      }
      let rollText = info.roll ? ` | Tirada 2d6: ${info.roll}` : '';
      let successText = '';
      if (info.roll) {
        successText = info.success ? (info.critical ? ' (Crítico)' : ' (Éxito)') : ' (Fallo)';
      }
      const damageText = info.roll ? ` | Daño: ${info.damage} | Vida defensor: ${info.defenderVida}` : '';
      const clawsText = info.clawsRoll ? ` | Garras d6: ${info.clawsRoll}` : '';
      const noteText = info.note ? ` | ${info.note}` : '';
      combatBox.textContent = `${info.action} ${info.attackerName} (${info.attacker}) vs ${info.defenderName} (${info.defender}) | Diferencia: ${info.difference}${rollText}${successText}${damageText}${clawsText}${noteText}`;
    }

    function prepareAttackInfo(attacker, defender, actionKey = 'attack') {
      const attackerStats = pieceMap.get(attacker);
      const defenderStats = pieceMap.get(defender);
      pendingAttackInfo = {
        action: actionLabel(actionKey),
        attacker: attackerStats.ataque,
        defender: defenderStats.defensa,
        difference: attackerStats.ataque - defenderStats.defensa,
        roll: null,
        success: null,
        critical: false,
        damage: 0,
        defenderVida: defenderStats.currentVida,
        attackerName: attackerStats.name,
        defenderName: defenderStats.name,
        clawsRoll: null,
        note: null,
      };
      attackButton.classList.add('button--pulse');
      updateCombatInfo();
    }

    function resolveAttack(attacker, defender, actionKey = 'attack', options = {}) {
      const { allowCounter = true, skipTurnAdvance = false, actionLabelOverride = null } = options;
      const attackerStats = pieceMap.get(attacker);
      const defenderStats = pieceMap.get(defender);
      const attackerSquare = getPieceSquare(attacker);
      const targetSquare = getPieceSquare(defender);
      const distance = attackDistance(attackerSquare, targetSquare);

      const die1 = Math.floor(Math.random() * 6) + 1;
      const die2 = Math.floor(Math.random() * 6) + 1;
      const roll = die1 + die2;
      const { success, critical, isPifia, shouldCounter } = evaluateAttackRoll(
        attackerStats,
        defenderStats,
        roll,
        distance,
        { allowCounter }
      );

      const { totalDamage, clawsRoll } = calculateDamage(attackerStats, defenderStats, distance, critical);
      const damageApplied = success && actionKey !== 'incapacitar' ? totalDamage : 0;
      if (success && actionKey === 'incapacitar') {
        setIncapacitated(defender, 1);
        if (isEnemy(attacker, defender)) {
          addPoints(attacker, SCORE_PER_DAMAGE);
        }
      }
      if (damageApplied > 0) {
        defenderStats.currentVida = Math.max(defenderStats.currentVida - damageApplied, 0);
        if (isEnemy(attacker, defender)) {
          addPoints(attacker, damageApplied * SCORE_PER_DAMAGE);
        }
      }

      pendingAttackInfo = {
        action: actionLabelOverride || actionLabel(actionKey),
        attacker: attackerStats.ataque,
        defender: defenderStats.defensa,
        difference: attackerStats.ataque - defenderStats.defensa,
        roll,
        success,
        critical,
        damage: damageApplied,
        defenderVida: defenderStats.currentVida,
        attackerName: attackerStats.name,
        defenderName: defenderStats.name,
        clawsRoll,
        note:
          actionKey === 'incapacitar'
            ? 'El ataque no causa daño.'
            : shouldCounter
            ? 'Pifia: el defensor realizará una réplica.'
            : null,
      };

      if (success && actionKey === 'incapacitar') {
        addHistoryEntry(attacker.dataset.team, `${attackerStats.name} incapacita a ${defenderStats.name}.`);
        playEffectSound(incapacitarSound);
      } else {
        const garrasText = clawsRoll ? ` (Garras d6=${clawsRoll})` : '';
        addHistoryEntry(
          attacker.dataset.team,
          `${attackerStats.name} ataca a ${defenderStats.name}: tirada ${roll}${
            critical ? ' (Crítico)' : isPifia ? ' (Pifia)' : ''
          }${success ? `, daño ${damageApplied}${garrasText}` : ', falla el ataque.'}${
            shouldCounter ? ' Réplica del defensor.' : ''
          }`
        );
      }

      if (success && actionKey !== 'incapacitar' && defenderStats.currentVida <= 0) {
        queueDeathMessage(`${defenderStats.name} ha sido eliminado por ${attackerStats.name}.`);
        if (isEnemy(attacker, defender)) {
          addPoints(attacker, SCORE_PER_KILL);
        }
        eliminatePiece(defender);
      }

      registerTurnSound({ damageDealt: damageApplied, attackFailed: !success });

      if (
        shouldCounter &&
        defenderStats.currentVida > 0 &&
        defender.dataset.eliminated !== 'true' &&
        attacker.dataset.eliminated !== 'true'
      ) {
        resolveAttack(defender, attacker, 'attack', {
          allowCounter: false,
          skipTurnAdvance: true,
          actionLabelOverride: 'Réplica',
        });
      }

      renderLifeCards();
      if (!skipTurnAdvance) {
        hideTooltip();
        clearRangeHighlights();
        selectedTarget = null;
        attackButton.classList.remove('button--pulse');
      }
      updateCombatInfo();
      if (!skipTurnAdvance) {
        finishTurn(attacker);
      }
    }

    function resolveExplosion(attacker, defender) {
      const attackerStats = pieceMap.get(attacker);
      const attackerSquare = getPieceSquare(attacker);
      const centerSquare = getPieceSquare(defender);
      const die1 = Math.floor(Math.random() * 6) + 1;
      const die2 = Math.floor(Math.random() * 6) + 1;
      const roll = die1 + die2;
      const critical = hasPassive(attackerStats, 'astucia') ? roll >= 11 : roll === 12;

      const deltas = [-1, 0, 1];
      const affectedPieces = [];
      const seenPieces = new Set();
      let totalDamageDealt = 0;
      let anySuccess = false;

      deltas.forEach((dr) => {
        deltas.forEach((dc) => {
          const row = Number(centerSquare.dataset.row) + dr;
          const col = Number(centerSquare.dataset.col) + dc;
          const square = getSquareAt(row, col);
          if (!square) return;
          const piece = square.querySelector('.piece');
          if (!piece || seenPieces.has(piece)) return;
          seenPieces.add(piece);
          affectedPieces.push({ piece, square });
        });
      });

      const targetsSummary = [];
      affectedPieces.forEach(({ piece, square }) => {
        const targetStats = pieceMap.get(piece);
        const distance = attackDistance(attackerSquare, square);
        const { success } = evaluateAttackRoll(attackerStats, targetStats, roll, distance, {
          allowCounter: false,
        });
        let damage = 0;
        if (success) {
          const { totalDamage } = calculateDamage(attackerStats, targetStats, distance, critical);
          damage = totalDamage;
          targetStats.currentVida = Math.max(targetStats.currentVida - damage, 0);
          totalDamageDealt += damage;
          if (isEnemy(attacker, piece)) {
            addPoints(attacker, damage * SCORE_PER_DAMAGE);
          }
          anySuccess = true;
        }
        targetsSummary.push({
          name: targetStats.name,
          success,
          damage,
          vida: targetStats.currentVida,
        });
        if (success && targetStats.currentVida <= 0) {
          queueDeathMessage(`${targetStats.name} ha sido eliminado por ${attackerStats.name}.`);
          if (isEnemy(attacker, piece)) {
            addPoints(attacker, SCORE_PER_KILL);
          }
          eliminatePiece(piece);
        }
      });

      pendingAttackInfo = {
        action: actionLabel('explosion'),
        attackerName: attackerStats.name,
        roll,
        critical,
        targets: targetsSummary,
      };

      playEffectSound(explosionSound);

      addHistoryEntry(
        attacker.dataset.team,
        `${attackerStats.name} ejecuta Explosión: tirada ${roll}${critical ? ' (Crítico)' : roll === 2 ? ' (Pifia)' : ''}. Afectados: ${targetsSummary
          .map((t) => `${t.name}${t.success ? ` daño ${t.damage}` : ' sin efecto'}`)
          .join('; ')}`
      );

      registerTurnSound({ damageDealt: totalDamageDealt, attackFailed: !anySuccess });

      renderLifeCards();
      hideTooltip();
      clearRangeHighlights();
      selectedTarget = null;
      attackButton.classList.remove('button--pulse');
      updateCombatInfo();
      finishTurn(attacker);
    }

    function resolvePulse(attacker) {
      const attackerStats = pieceMap.get(attacker);
      const attackerSquare = getPieceSquare(attacker);
      const maxRange = rangeForPiece(attacker);

      const affectedPieces = [];
      let totalDamageDealt = 0;
      squares.forEach((square) => {
        const occupant = square.querySelector('.piece');
        if (!occupant) return;
        const distance = attackDistance(attackerSquare, square);
        if (distance <= maxRange) {
          affectedPieces.push({ piece: occupant, square, distance });
        }
      });

      const targetsSummary = [];

      affectedPieces.forEach(({ piece, square, distance }) => {
        const targetStats = pieceMap.get(piece);
        const die1 = Math.floor(Math.random() * 6) + 1;
        const die2 = Math.floor(Math.random() * 6) + 1;
        const roll = die1 + die2;
        const { success, critical, isPifia } = evaluateAttackRoll(attackerStats, targetStats, roll, distance, {
          allowCounter: false,
        });
        let damage = 0;
        if (success) {
          const { totalDamage } = calculateDamage(attackerStats, targetStats, distance, critical);
          damage = totalDamage;
          targetStats.currentVida = Math.max(targetStats.currentVida - damage, 0);
          totalDamageDealt += damage;
          if (isEnemy(attacker, piece)) {
            addPoints(attacker, damage * SCORE_PER_DAMAGE);
          }
        }
        targetsSummary.push({
          name: targetStats.name,
          success,
          damage,
          vida: targetStats.currentVida,
          roll,
          critical,
          isPifia,
        });
        if (success && targetStats.currentVida <= 0) {
          queueDeathMessage(`${targetStats.name} ha sido eliminado por ${attackerStats.name}.`);
          if (isEnemy(attacker, piece)) {
            addPoints(attacker, SCORE_PER_KILL);
          }
          eliminatePiece(piece);
        }
      });

      pendingAttackInfo = {
        action: actionLabel('pulso'),
        attackerName: attackerStats.name,
        roll: '-',
        critical: false,
        targets: targetsSummary,
      };

      playEffectSound(explosionSound);

      addHistoryEntry(
        attacker.dataset.team,
        `${attackerStats.name} activa Pulso: ${targetsSummary
          .map((t) => `${t.name} (tirada ${t.roll}${t.critical ? ' crítico' : t.isPifia ? ' pifia' : ''}${
            t.success ? `, daño ${t.damage}` : ', sin efecto'
          })`)
          .join('; ')}`
      );

      const allMissed = targetsSummary.every((t) => !t.success);
      registerTurnSound({ damageDealt: totalDamageDealt, attackFailed: allMissed });

      renderLifeCards();
      hideTooltip();
      clearRangeHighlights();
      selectedTarget = null;
      attackButton.classList.remove('button--pulse');
      updateCombatInfo();
      finishTurn(attacker);
    }

    function clearTargetSelection(preserveAttack = false) {
      squares.forEach((square) => square.classList.remove('square--target'));
      selectedTarget = null;
      if (!preserveAttack) {
        pendingAttackInfo = null;
      }
      attackButton.classList.remove('button--pulse');
      hideTooltip();
      updateCombatInfo();
      if (turnOrder.length > 0) {
        highlightRange(turnOrder[turnIndex]);
      }
    }

    function handleActionClick(actionKey) {
      currentAction = actionKey;
      const attacker = turnOrder[turnIndex];
      if (actionKey === 'pulso') {
        resolvePulse(attacker);
        return;
      }
      if (!selectedTarget) {
        alert('Selecciona primero un enemigo dentro de tu rango.');
        return;
      }
      const attackerSquare = getPieceSquare(attacker);
      const targetSquare = getPieceSquare(selectedTarget);
      const maxRange = rangeForPiece(attacker);
      if (!isWithinAttackRange(attackerSquare, targetSquare, maxRange)) {
        alert('El objetivo está fuera de rango.');
        clearTargetSelection();
        return;
      }
      prepareAttackInfo(attacker, selectedTarget, actionKey);
      if (actionKey === 'explosion') {
        resolveExplosion(attacker, selectedTarget);
      } else {
        resolveAttack(attacker, selectedTarget, actionKey);
      }
    }

    attackButton.addEventListener('click', () => handleActionClick('attack'));

    const movementPool = new Map();

    function remainingMovement(piece) {
      return movementPool.get(piece) ?? Number(piece.dataset.movimiento);
    }

    function resetMovement(piece) {
      movementPool.set(piece, Number(piece.dataset.movimiento));
    }

    function spendMovement(piece, amount) {
      const left = Math.max(remainingMovement(piece) - amount, 0);
      movementPool.set(piece, left);
    }

    board.addEventListener('click', async (event) => {
      const activePiece = turnOrder[turnIndex];
      if (activePiece?.dataset.team === 'enemigo') return;

      const square = event.target.closest('.square');
      if (!square) return;

      const targetPiece = square.querySelector('.piece');

      if (targetPiece && targetPiece !== activePiece) {
        if (targetPiece.dataset.team === activePiece.dataset.team) return;
        const attackerSquare = getPieceSquare(activePiece);
        const maxRange = rangeForPiece(activePiece);
        if (!isWithinAttackRange(attackerSquare, square, maxRange)) {
          alert('Objetivo fuera de rango.');
          clearTargetSelection();
          return;
        }
        clearTargetSelection();
        square.classList.add('square--target');
        selectedTarget = targetPiece;
        prepareAttackInfo(activePiece, targetPiece, currentAction);
        return;
      }

      if (!square.classList.contains('square--move')) return;
      if (square.querySelector('.piece')) return;
      const distance = movementDistances.get(square);
      if (distance === undefined || distance > remainingMovement(activePiece)) return;
      if (activePiece.dataset.key === HULK_KEY) {
        setHulkAnimation('andar');
      }
      await animatePieceToSquare(activePiece, square);
      spendMovement(activePiece, distance);
      clearHighlights();
      highlightMovement(activePiece);
      highlightRange(activePiece);
      updateStatusBar(activePiece);
      if (activePiece.dataset.key === HULK_KEY) {
        setHulkAnimation('activo');
      }
    });

    function attachTooltipEvents(piece) {
      piece.addEventListener('pointerenter', () => {
        const activePiece = turnOrder[turnIndex];
        if (piece === activePiece || piece.dataset.team === activePiece.dataset.team) {
          hideTooltip();
          return;
        }
        showTooltip(piece);
      });

      piece.addEventListener('pointerleave', () => {
        hideTooltip();
      });
    }

    pieces.forEach(({ element }) => {
      if (element) {
        attachTooltipEvents(element);
      }
    });

    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function animatePieceToSquare(piece, square, options = {}) {
      return new Promise((resolve) => {
        const duration = Number(options.duration ?? movementAnimationDuration);
        if (!piece || !square) {
          resolve();
          return;
        }

        if (!Number.isFinite(duration) || duration <= 0) {
          square.appendChild(piece);
          resolve();
          return;
        }

        const startRect = piece.getBoundingClientRect();
        square.appendChild(piece);
        const endRect = piece.getBoundingClientRect();
        const deltaX = startRect.left - endRect.left;
        const deltaY = startRect.top - endRect.top;

        const animation = piece.animate(
          [
            { transform: `translate(-50%, -50%) translate(${deltaX}px, ${deltaY}px)` },
            { transform: 'translate(-50%, -50%)' },
          ],
          {
            duration,
            easing: 'ease-in-out',
          },
        );

        animation.addEventListener('finish', resolve);
        animation.addEventListener('cancel', resolve);
      });
    }

    function findClosestEnemy(piece) {
      const origin = getPieceSquare(piece);
      if (!origin) return null;
      const opponents = pieces
        .map((p) => p.element)
        .filter((p) => p && p.dataset.team === 'aliado' && p.dataset.eliminated !== 'true');
      let best = null;
      let bestDistance = Infinity;
      opponents.forEach((candidate) => {
        const sq = getPieceSquare(candidate);
        if (!sq) return;
        const distance = attackDistance(origin, sq);
        if (distance < bestDistance) {
          bestDistance = distance;
          best = candidate;
        }
      });
      return best;
    }

    function chooseEnemyMoveSquare(piece, targetSquare) {
      computeReachableSquares(piece);
      const origin = getPieceSquare(piece);
      const maxRange = rangeForPiece(piece);
      if (origin && targetSquare && isWithinAttackRange(origin, targetSquare, maxRange)) {
        return null;
      }
      let bestSquare = null;
      let bestDistance = Infinity;
      movementDistances.forEach((_, square) => {
        const distance = attackDistance(square, targetSquare);
        if (distance < bestDistance) {
          bestDistance = distance;
          bestSquare = square;
        }
      });
      return bestSquare;
    }

    function selectBestEnemyAction(piece, targetPiece) {
      const stats = pieceMap.get(piece);
      const abilities = stats?.habilidades?.activas || [];
      const targetStats = pieceMap.get(targetPiece);
      const targetSquare = getPieceSquare(targetPiece);
      const origin = getPieceSquare(piece);
      const inRange = origin && targetSquare && isWithinAttackRange(origin, targetSquare, rangeForPiece(piece));
      if (!inRange) return 'move';

      if (abilities.includes('explosion')) {
        const deltas = [-1, 0, 1];
        let neighbors = 0;
        deltas.forEach((dr) => {
          deltas.forEach((dc) => {
            const sq = getSquareAt(Number(targetSquare.dataset.row) + dr, Number(targetSquare.dataset.col) + dc);
            if (sq?.querySelector('.piece')) neighbors += 1;
          });
        });
        if (neighbors >= 2) {
          return 'explosion';
        }
      }

      if (abilities.includes('incapacitar') && targetStats?.incapacitatedTurns === 0) {
        return 'incapacitar';
      }

      return 'attack';
    }

    async function performEnemyTurn(piece) {
      const target = findClosestEnemy(piece);
      if (!target) {
        finishTurn(piece);
        return;
      }

      const targetSquare = getPieceSquare(target);
      const chosenAction = selectBestEnemyAction(piece, target);

      if (chosenAction === 'move') {
        const moveSquare = chooseEnemyMoveSquare(piece, targetSquare);
        if (moveSquare) {
          const distance = movementDistances.get(moveSquare) ?? 0;
          clearHighlights();
          highlightMovement(piece);
          moveSquare.classList.add('square--target');
          await sleep(ENEMY_ACTION_DELAY_MS);
          await animatePieceToSquare(piece, moveSquare);
          spendMovement(piece, distance);
          clearHighlights();
          highlightMovement(piece);
          highlightRange(piece);
          updateStatusBar(piece);
        }
      }

      await sleep(ENEMY_ACTION_DELAY_MS);
      const refreshedTarget = findClosestEnemy(piece) || target;
      const action = selectBestEnemyAction(piece, refreshedTarget);
      if (action === 'move') {
        finishTurn(piece);
        return;
      }
      selectedTarget = refreshedTarget;
      handleActionClick(action);
    }

    function applyRegeneration(piece) {
      const stats = pieceMap.get(piece);
      if (!stats || !hasPassive(stats, 'regeneracion')) return;
      if (stats.currentVida < stats.maxVida) {
        stats.currentVida = Math.min(stats.currentVida + 1, stats.maxVida);
        renderLifeCards();
        addHistoryEntry(piece.dataset.team, `${stats.name} se regenera (vida ${stats.currentVida}).`, {
          preserveLatest: true,
        });
      }
    }

    function advanceTurn() {
      if (turnOrder.length === 0) return;
      turnIndex = (turnIndex + 1) % turnOrder.length;
      const nextPiece = turnOrder[turnIndex];
      const delay = nextPiece?.dataset.team === 'enemigo' ? AI_DELAY_MS : TURN_DELAY_MS;
      setTimeout(() => startTurn(nextPiece), delay);
    }

    async function finishTurn(piece, options = {}) {
      const { skipRegeneration = false, summaryOverride = null } = options;
      setHulkAnimation('espera');
      if (!skipRegeneration) {
        applyRegeneration(piece);
      }
      const stats = pieceMap.get(piece);
      const summary =
        summaryOverride || latestActionMessage || (stats ? `${stats.name} finaliza su turno.` : 'Turno completado.');
      latestActionMessage = null;
      await showTurnPopup(summary);
      if (pendingDeathMessages.length > 0) {
        await showQueuedDeathPopups();
      }
      advanceTurn();
    }

    function startTurn(piece) {
      if (!piece) return;
      const stats = pieceMap.get(piece);
      if (!stats) return;
      if (piece.dataset.key === HULK_KEY) {
        setHulkAnimation('activo');
      } else {
        setHulkAnimation('espera');
      }
      if (stats.incapacitatedTurns && stats.incapacitatedTurns > 0) {
        const incapMessage = `${stats.name} pierde el turno por estar incapacitado.`;
        addHistoryEntry(piece.dataset.team, incapMessage);
        stats.incapacitatedTurns -= 1;
        if (stats.incapacitatedTurns <= 0) {
          piece.classList.remove('piece--incapacitated');
        }
        renderLifeCards();
        finishTurn(piece, { summaryOverride: incapMessage });
        return;
      }
      resetMovement(piece);
      setActivePiece(piece);
      clearTargetSelection(true);
      clearHighlights();
      highlightMovement(piece);
      highlightRange(piece);
      if (piece.dataset.team === 'enemigo') {
        performEnemyTurn(piece);
      }
    }

    passButton.addEventListener('click', () => {
      const currentPiece = turnOrder[turnIndex];
      playEffectSound(passTurnSound);
      finishTurn(currentPiece);
    });

    startTurn(turnOrder[turnIndex]);
  </script>
</body>
</html>
