<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tablero 10x10</title>
  <style>
    :root {
      --square-size: 70px;
      --board-columns: 16;
      --board-rows: 10;
      --board-width: calc(var(--square-size) * var(--board-columns));
      --board-height: calc(var(--square-size) * var(--board-rows));
      --board-color: #1f8a3b;
      --square-border: #0f4d20;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, #0f4d20 0%, #0d3618 100%);
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      color: #f4f4f4;
    }

    .wrapper {
      text-align: center;
      padding: 24px 18px 40px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .start-screen {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      gap: 16px;
      justify-items: center;
      text-align: center;
      background: linear-gradient(180deg, #0f4d20 0%, #0d3618 100%);
      padding: 24px 16px;
      z-index: 50;
      transition: opacity 220ms ease, visibility 220ms ease;
    }

    .start-screen--hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    .start-screen__headline {
      font-size: clamp(28px, 4vw, 36px);
      margin: 0;
      letter-spacing: 0.3px;
    }

    .start-screen__subtitle {
      margin: 0;
      opacity: 0.85;
      font-weight: 600;
    }

    .draft-screen {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.08), transparent 35%),
        radial-gradient(circle at 80% 15%, rgba(255, 200, 120, 0.06), transparent 32%),
        linear-gradient(180deg, #0f4d20 0%, #0d3618 100%);
      display: grid;
      place-items: center;
      padding: clamp(16px, 4vw, 36px);
      z-index: 45;
      transition: opacity 200ms ease, visibility 200ms ease;
    }

    .draft-screen[hidden] {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    .draft-panel {
      width: min(1600px, 98vw);
      background: rgba(10, 28, 16, 0.92);
      border: 2px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.45);
      border-radius: 20px;
      padding: clamp(16px, 1.6vw, 24px);
      display: grid;
      gap: 14px;
      color: #f4f4f4;
      max-height: min(920px, 94vh);
      overflow: auto;
    }

    .draft-header {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: baseline;
      flex-wrap: wrap;
    }

    .draft-kicker {
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-weight: 800;
      font-size: 0.9rem;
      opacity: 0.9;
      color: #ffd166;
    }

    .draft-title {
      margin: 4px 0 0;
      font-size: clamp(26px, 3vw, 34px);
      letter-spacing: 0.04em;
    }

    .draft-subtitle {
      margin: 6px 0 0;
      opacity: 0.9;
      font-weight: 500;
    }

    .draft-meta {
      text-align: right;
      min-width: 220px;
    }

    .draft-meta strong {
      display: block;
      font-size: clamp(18px, 2.2vw, 22px);
    }

    .draft-legend {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 0.95rem;
      opacity: 0.92;
    }

    .draft-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .draft-swatch {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      background: #2b9afc;
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.2);
    }

    .draft-swatch--enemy {
      background: #ef3f3f;
    }

    .draft-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
      align-items: start;
    }

    .draft-card {
      position: relative;
      background: #0b0b0b;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 10px 18px rgba(0, 0, 0, 0.45);
      cursor: pointer;
      transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease, opacity 140ms ease;
      isolation: isolate;
      min-height: 150px;
    }

    .draft-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 14px 22px rgba(0, 0, 0, 0.5);
      border-color: rgba(255, 209, 102, 0.6);
    }

    .draft-card:active {
      transform: translateY(0);
    }

    .draft-card__image {
      width: 100%;
      aspect-ratio: 1 / 1;
      object-fit: cover;
      display: block;
      filter: saturate(1.05);
    }

    .draft-card__body {
      position: absolute;
      inset: auto 0 0;
      padding: 10px 12px 12px;
      background: linear-gradient(180deg, transparent, rgba(0, 0, 0, 0.8));
    }

    .draft-card__title {
      margin: 0;
      font-size: 1.02rem;
      letter-spacing: 0.03em;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
      line-height: 1.2;
      color: #ffffff;
      font-weight: 800;
    }

    .draft-card--taken {
      opacity: 0.45;
      pointer-events: none;
    }

    .draft-card--taken::after {
      content: attr(data-owner);
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.6);
      color: #ffd166;
      font-weight: 900;
      letter-spacing: 0.08em;
      font-size: 1.05rem;
      text-transform: uppercase;
    }

    .draft-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
    }

    .draft-prompt {
      margin: 0;
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .start-screen__modes {
      display: none;
      gap: 12px;
      justify-items: center;
    }

    .start-screen__modes[hidden] {
      display: none !important;
    }

    .start-screen--modes .start-screen__modes {
      display: grid;
      animation: fadeIn 240ms ease;
    }

    .start-screen__buttons {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-bottom: 16px;
    }

    .button {
      background: #f4f4f4;
      color: #0d3618;
      border: none;
      border-radius: 8px;
      padding: 10px 16px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
    }

    .button:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      background: #ffffff;
    }

    .button:active {
      transform: translateY(0);
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.28);
    }

    .button--primary {
      background: #f17c00;
      color: #fff8f0;
    }

    .button--primary:hover {
      background: #ff9400;
    }

    .button--pulse {
      animation: pulse 0.8s ease-in-out infinite;
      box-shadow: 0 0 0 0 rgba(241, 124, 0, 0.65);
    }

    .start-screen__play {
      padding: 16px 36px;
      font-size: clamp(18px, 4vw, 24px);
      letter-spacing: 0.6px;
      border-radius: 18px;
      background: linear-gradient(135deg, #ffae34 0%, #ff6b00 50%, #ffd166 100%);
      color: #1c1200;
      box-shadow:
        0 12px 24px rgba(0, 0, 0, 0.35),
        0 0 18px rgba(255, 174, 52, 0.6),
        inset 0 2px 0 rgba(255, 255, 255, 0.35);
      border: 2px solid rgba(255, 230, 184, 0.7);
      text-transform: uppercase;
      position: relative;
      overflow: hidden;
    }

    .start-screen__play::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, transparent 0%, rgba(255, 255, 255, 0.35) 40%, transparent 80%);
      transform: translateX(-120%);
      transition: transform 450ms ease;
    }

    .start-screen__play:hover::after {
      transform: translateX(120%);
    }

    .start-screen__play:active {
      transform: translateY(1px);
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(241, 124, 0, 0.65);
      }
      70% {
        box-shadow: 0 0 0 12px rgba(241, 124, 0, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(241, 124, 0, 0);
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(8px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .board {
      width: calc(var(--board-width) + 16px);
      height: calc(var(--board-height) + 16px);
      display: grid;
      grid-template-columns: repeat(var(--board-columns), var(--square-size));
      grid-template-rows: repeat(var(--board-rows), var(--square-size));
      background-color: var(--board-color);
      border: 8px solid #0b2a13;
      border-radius: 12px;
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
      overflow: hidden;
      box-sizing: content-box;
      justify-self: center;
    }

    .square {
      position: relative;
      width: var(--square-size);
      height: var(--square-size);
      border: 1px solid var(--square-border);
      background-color: var(--board-color);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .piece {
      position: absolute;
      width: 80%;
      height: 80%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
      border: 3px solid rgba(255, 255, 255, 0.3);
      display: grid;
      place-items: center;
      background: #0d0d0d;
      overflow: hidden;
      z-index: 3;
      transition: box-shadow 160ms ease, outline-color 160ms ease;
    }

    .piece[data-team='aliado'] {
      border-color: #2b9afc;
      box-shadow: 0 4px 10px rgba(0, 98, 204, 0.45);
    }

    .piece[data-team='enemigo'] {
      border-color: #ef3f3f;
      box-shadow: 0 4px 10px rgba(215, 44, 44, 0.45);
    }

    .piece__image {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .piece__name {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .piece--active {
      outline: 4px solid #fbd34d;
      outline-offset: 1px;
      box-shadow: 0 0 0 6px rgba(251, 211, 77, 0.35), 0 6px 14px rgba(0, 0, 0, 0.35);
      animation: active-glow 0.9s ease-in-out infinite;
    }

    @keyframes active-glow {
      0% {
        outline-color: rgba(251, 211, 77, 0.25);
        box-shadow: 0 0 0 2px rgba(251, 211, 77, 0.35), 0 6px 14px rgba(0, 0, 0, 0.35);
        filter: brightness(1);
      }
      50% {
        outline-color: rgba(251, 211, 77, 0.9);
        box-shadow: 0 0 0 8px rgba(251, 211, 77, 0.6), 0 10px 18px rgba(0, 0, 0, 0.45);
        filter: brightness(1.18);
      }
      100% {
        outline-color: rgba(251, 211, 77, 0.25);
        box-shadow: 0 0 0 2px rgba(251, 211, 77, 0.35), 0 6px 14px rgba(0, 0, 0, 0.35);
        filter: brightness(1);
      }
    }

    .square::before,
    .square::after {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 120ms ease;
    }

    .square::before {
      z-index: 1;
    }

    .square::after {
      z-index: 2;
    }

    .square--range::after {
      opacity: 1;
      box-shadow: inset 0 0 0 5px rgba(255, 132, 0, 0.85);
      background: none;
    }

    .square--target {
      box-shadow: inset 0 0 0 4px rgba(255, 171, 64, 0.9), inset 0 0 0 7px rgba(255, 171, 64, 0.35);
    }

    .square--move::before {
      opacity: 1;
      box-shadow: inset 0 0 0 4px rgba(0, 0, 0, 0.45);
      background: radial-gradient(circle at 50% 50%, rgba(0, 0, 0, 0.28), transparent 70%);
    }

    .tooltip {
      position: fixed;
      top: 0;
      left: 0;
      transform: none;
      background: #0f4d20;
      color: #f4f4f4;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 14px 16px;
      box-shadow: 0 16px 32px rgba(0, 0, 0, 0.4);
      pointer-events: none;
      white-space: nowrap;
      font-size: 0.95rem;
      z-index: 20;
      min-width: 240px;
      max-width: 320px;
    }

    .tooltip h3 {
      margin: 0 0 6px;
      font-size: 1rem;
    }

    .tooltip ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 4px 8px;
    }

    .layout {
      display: grid;
      grid-template-columns: 340px auto 340px;
      gap: 16px;
      align-items: start;
      width: fit-content;
      margin: 0 auto;
      justify-content: center;
    }

    .turn-popup,
    .death-popup {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.45);
      z-index: 30;
    }

    .turn-popup[hidden],
    .death-popup[hidden] {
      display: none;
    }

    .turn-popup__content,
    .death-popup__content {
      position: relative;
      background: #0f4d20;
      border: 2px solid rgba(255, 255, 255, 0.35);
      border-radius: 14px;
      padding: 18px 20px;
      width: min(1120px, 96vw);
      max-width: min(1120px, 96vw);
      height: 700px;
      max-height: 700px;
      box-shadow: 0 20px 36px rgba(0, 0, 0, 0.45);
      text-align: center;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .turn-popup__layout {
      position: relative;
      display: flex;
      gap: 0;
      align-items: stretch;
      justify-content: center;
      z-index: 1;
      min-height: 0;
      height: 100%;
      flex: 1 1 auto;
    }

    .turn-popup__headline {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      width: calc(100% - 32px);
      max-width: none;
      padding: clamp(14px, 1.8vw, 28px) clamp(18px, 2vw, 32px);
      background: linear-gradient(120deg, rgba(0, 0, 0, 0.78), rgba(15, 77, 32, 0.9));
      border-radius: 14px;
      box-shadow: 0 16px 30px rgba(0, 0, 0, 0.45);
      z-index: 5;
      pointer-events: none;
    }

    .turn-popup__message,
    .death-popup__message {
      margin: 0;
      font-size: clamp(0.75rem, 0.9vw + 0.45rem, 1.2rem);
      line-height: 1.35;
      font-family: 'Impact', 'Anton', system-ui, sans-serif;
      letter-spacing: 0.05em;
      text-shadow: 0 3px 10px rgba(0, 0, 0, 0.55), 0 0 30px rgba(251, 211, 77, 0.35);
      text-transform: none;
      width: 100%;
    }

    .turn-popup__hint {
      margin: 0;
      font-size: clamp(1.05rem, 0.6vw + 0.9rem, 1.35rem);
      opacity: 0.95;
      font-weight: 800;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .turn-popup__center {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 16px;
      justify-content: flex-end;
      align-items: center;
      z-index: 3;
      pointer-events: none;
    }

    .duel-panel {
      position: relative;
      flex: 1 1 0;
      min-width: 0;
      height: 590px;
      min-height: 590px;
      background: #0a0a0a;
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.25);
      box-shadow: 0 18px 36px rgba(0, 0, 0, 0.55);
      display: flex;
      gap: 0;
      padding: 0;
    }

    .duel-panel__empty {
      margin: auto;
      opacity: 0.65;
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .duel-card {
      position: relative;
      flex: 1 1 auto;
      min-width: 0;
      border-radius: 10px;
      overflow: hidden;
      display: flex;
      align-items: flex-end;
      justify-content: flex-start;
      background: #111;
      isolation: isolate;
      min-height: 100%;
      display: flex;
      flex-direction: column; /* Asegura que el contenido fluya verticalmente */
      justify-content: flex-end; /* Alinea al fondo */
    }

    .duel-card__image {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      filter: saturate(1.1);
      z-index: 0;
    }

    .duel-card__overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.25), rgba(0, 0, 0, 0.7));
      z-index: 1;
      mix-blend-mode: screen;
      opacity: 0.9;
    }

    .duel-card__overlay--attacker {
      background: linear-gradient(200deg, rgba(24, 114, 255, 0.55), rgba(11, 40, 94, 0.9));
    }

    .duel-card__overlay--defender {
      background: linear-gradient(200deg, rgba(255, 71, 102, 0.65), rgba(115, 16, 35, 0.9));
    }

    .duel-card__label {
      position: absolute;
      inset: auto 0 0;
      z-index: 2;
      width: 100%;
      padding: clamp(14px, 1.6vw, 22px) clamp(16px, 1.8vw, 26px);
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.05) 0%, rgba(0, 0, 0, 0.55) 35%, rgba(0, 0, 0, 0.8) 100%);
      color: #fff;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
      font-family: 'Impact', 'Anton', system-ui, sans-serif;
      letter-spacing: 0.04em;
      word-break: break-word;
      backdrop-filter: blur(2px);
      padding-bottom: clamp(16px, 2vw, 30px);
    }

    .duel-card__name {
      /* Usamos la variable que calcula JS, pero forzamos el ajuste */
      font-size: var(--duel-name-size, 1rem); 
      margin: 0 0 4px;
      text-transform: uppercase;
      line-height: 1; /* Línea más ajustada */

      white-space: normal; 
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
    }

    .duel-card__stats {
      margin: 0;
      font-size: clamp(0.9rem, 0.6vw + 0.7rem, 1.1rem);
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-weight: 700;
      align-items: flex-start;
    }

    .duel-card__badge {
      background: rgba(0, 0, 0, 0.4);
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      box-shadow: 0 8px 14px rgba(0, 0, 0, 0.35);
      display: inline-block;
    }

    .duel-card--eliminated .duel-card__overlay {
      background: linear-gradient(200deg, rgba(255, 77, 77, 0.8), rgba(117, 10, 10, 0.92));
    }

    .duel-card--eliminated .duel-card__label {
      background: linear-gradient(180deg, rgba(60, 0, 0, 0.35) 0%, rgba(0, 0, 0, 0.75) 40%, rgba(0, 0, 0, 0.9) 100%);
    }

    .duel-panel--hidden {
      display: none;
    }

    .card-panel {
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
      display: flex;
      flex-direction: column;
    }

    .card-panel h3 {
      margin: 0 0 8px;
      font-size: 1rem;
      letter-spacing: 0.02em;
    }

    .card-panel__content {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: stretch;
      flex: 1;
    }

    .life-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex: 1;
    }

    .life-card {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(15, 77, 32, 0.65);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 700;
      color: #f4f4f4;
      text-align: left;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08);
    }

    .life-card--eliminated {
      background: linear-gradient(135deg, rgba(120, 6, 6, 0.8), rgba(40, 0, 0, 0.75));
      border-color: rgba(255, 99, 99, 0.55);
    }

    .life-card__main {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      min-width: 0;
    }

    .life-card__avatar {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      object-fit: cover;
      border: 1px solid rgba(255, 255, 255, 0.35);
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
      background: #0d0d0d;
    }

    .life-card__label {
      display: block;
      line-height: 1.2;
      max-width: 100%;
      font-size: clamp(0.82rem, 1vw + 0.35rem, 1.05rem);
      word-break: break-word;
    }

    .life-card__meta {
      font-variant-numeric: tabular-nums;
      margin-left: auto;
      font-size: clamp(0.8rem, 0.8vw + 0.45rem, 1.02rem);
      opacity: 0.95;
      text-align: right;
    }

    .status-bar {
      margin-bottom: 12px;
      display: flex;
      justify-content: center;
      gap: 16px;
      align-items: center;
      font-weight: 700;
    }

    .piece--incapacitated::after {
      content: '✖';
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(255, 0, 0, 0.35);
      color: #fff;
      font-size: 42px;
      font-weight: 900;
      pointer-events: none;
    }
    /* Busca .tooltip en tu CSS y actualízalo o añade esto al final del style */
.tooltip {
    /* Mantenemos lo que tenías y aseguramos el z-index alto */
    z-index: 1000; 
    max-width: 350px; /* Un poco más ancho para los textos de poderes */
}

/* --- ARREGLO DE ESTILOS DEL TOOLTIP --- */

/* Espacio entre cada poder individual */
.tooltip .power-list li {
    margin-bottom: 5px;
    line-height: 1.3; /* Un poco más de altura para que no se choquen verticalmente */
}

/* Títulos de sección (Activos/Pasivos) */
.tooltip h4 {
    margin: 12px 0 4px 0; /* Un poco de aire por encima */
    color: #ffd166;       /* Color dorado */
    font-size: 0.95rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1); /* Línea separadora sutil */
}

/* Contenedor de la lista */
.tooltip .power-list {
    padding-left: 20px;
    margin: 0; /* Quitamos margen por defecto */
}
  </style>
</head>
<body>
  <div id="startScreen" class="start-screen start-screen--hidden" hidden>
    <div>
      <h1 class="start-screen__headline">Marvel Force</h1>
      <p class="start-screen__subtitle">Elige cómo quieres jugar</p>
    </div>
    <button id="playButton" class="button button--primary button--pulse start-screen__play" type="button">Jugar</button>
    <div id="modeSelection" class="start-screen__modes" hidden>
      <p class="start-screen__subtitle">Selecciona el modo</p>
      <div class="start-screen__buttons">
        <button class="button" type="button" data-mode="pvp" onclick="handleModeSelection('pvp')">1 vs 1</button>
        <button class="button button--primary" type="button" data-mode="ai" onclick="handleModeSelection('ai')">1 vs IA</button>
      </div>
    </div>
  </div>

  <div id="draftScreen" class="draft-screen" hidden>
    <div class="draft-panel" role="dialog" aria-labelledby="draftTitle" aria-live="polite">
      <div class="draft-header">
        <div>
          <p class="draft-kicker">Fase de selección</p>
          <h2 id="draftTitle" class="draft-title">Elige tu equipo</h2>
          <p id="draftSubtitle" class="draft-subtitle">Se asignará aleatoriamente quién elige primero.</p>
        </div>
        <div class="draft-meta">
          <span id="draftPicker" class="draft-subtitle"></span>
          <strong id="draftTurn">Turno de selección</strong>
          <span id="draftCounter" class="draft-subtitle"></span>
        </div>
      </div>
      <div class="draft-legend">
        <span class="draft-badge"><span class="draft-swatch"></span> Equipo del Jugador 1</span>
        <span class="draft-badge"><span class="draft-swatch draft-swatch--enemy"></span> Equipo del Jugador 2 / IA</span>
      </div>
      <p id="draftPrompt" class="draft-prompt">Cargando personajes...</p>
      <div id="draftGrid" class="draft-grid" aria-label="Personajes disponibles para elegir"></div>
      <div class="draft-footer">
        <p id="draftInfo" class="draft-subtitle"></p>
      </div>
    </div>
  </div>

  <main id="gameContainer" class="wrapper" hidden>
    <div class="controls" aria-label="Controles de turno">
      <button class="button" id="passTurn" type="button">Pasar</button>
      <button class="button button--primary" id="attack" type="button">Atacar</button>
    </div>
    <div class="controls" id="powerControls" aria-label="Poderes activos"></div>
    <div class="status-bar" aria-live="polite">
      <span id="turnInfo">Turno:</span>
      <span id="movementInfo"></span>
    </div>

    <div class="layout">
      <aside class="card-panel" aria-label="Vida aliados">
        <h3>Aliados</h3>
        <div class="card-panel__content">
          <div class="life-list" id="allyCards"></div>
        </div>
      </aside>
      <section class="board" aria-label="Tablero de 100 cuadros verdes"></section>
      <aside class="card-panel" aria-label="Vida enemigos">
        <h3>Enemigos</h3>
        <div class="card-panel__content">
          <div class="life-list" id="enemyCards"></div>
        </div>
      </aside>
    </div>
  </main>
  <div id="tooltip" class="tooltip" hidden></div>
  <div id="turnPopup" class="turn-popup" hidden>
    <div class="turn-popup__content">
      <div class="turn-popup__headline">
        <p id="turnPopupMessage" class="turn-popup__message"></p>
      </div>
      <div class="turn-popup__layout">
        <div class="duel-panel" id="allyPanel" aria-label="Aliados en el duelo">
          <div class="duel-panel__empty">Sin aliados destacados</div>
        </div>
        <div class="turn-popup__center">
          <p class="turn-popup__hint">Pulsa cualquier tecla o botón para continuar</p>
        </div>
        <div class="duel-panel" id="enemyPanel" aria-label="Enemigos en el duelo">
          <div class="duel-panel__empty">Sin enemigos destacados</div>
        </div>
      </div>
    </div>
  </div>
  <div id="deathPopup" class="death-popup" hidden>
    <div class="death-popup__content">
      <p id="deathPopupMessage" class="death-popup__message"></p>
      <p class="turn-popup__hint">Pulsa cualquier tecla o botón para continuar</p>
    </div>
  </div>

    <script src="js/poderes.js"></script>
    <script src="js/personajes.js"></script>
    <script>
      const board = document.querySelector('.board');
      const startScreen = document.getElementById('startScreen');
      const draftScreen = document.getElementById('draftScreen');
      const gameContainer = document.getElementById('gameContainer');
      const playButton = document.getElementById('playButton');
      const modeSelection = document.getElementById('modeSelection');
      const modeButtons = modeSelection.querySelectorAll('[data-mode]');
      const draftGrid = document.getElementById('draftGrid');
      const draftPrompt = document.getElementById('draftPrompt');
      const draftPicker = document.getElementById('draftPicker');
      const draftTurn = document.getElementById('draftTurn');
      const draftCounter = document.getElementById('draftCounter');
      const draftInfo = document.getElementById('draftInfo');
      const draftSubtitle = document.getElementById('draftSubtitle');
      const pieceStats =
        (typeof personajes !== 'undefined' && personajes) ||
        (typeof window !== 'undefined' ? window.personajes : {});

      Object.entries(pieceStats).forEach(([key, stats]) => {
        if (!stats.name && stats.nombre) {
          stats.name = stats.nombre;
        }

        if (!stats.nombre && stats.name) {
          stats.nombre = stats.name;
        }

        if (!stats.nombre && !stats.name) {
          stats.name = key;
          stats.nombre = key;
        }

        const baseDamage = stats.dano ?? stats.danoCC ?? stats.danoAD ?? 0;
        stats.dano = baseDamage;
        stats.danoCC = stats.danoCC ?? baseDamage;
        stats.danoAD = stats.danoAD ?? baseDamage;

        const baseResistencia = stats.resistencia ?? stats.resistenciaCC ?? stats.resistenciaAD ?? 0;
        stats.resistencia = baseResistencia;
      });
      const SCORE_PER_DAMAGE = 10;
      const SCORE_PER_KILL = 50;
      
      const punchSound = new Audio('sonidos/efectos/punch.mp3');
      const ohSound = new Audio('sonidos/efectos/oh.mp3');
      const failureSound = new Audio('sonidos/efectos/failure.mp3');
      const passTurnSound = new Audio('sonidos/efectos/pasar.wav');
      const deathSound = new Audio('sonidos/efectos/muerte.wav');

      const criticoSound = new Audio('sonidos/efectos/critico.mp3');
      const pifiaSound = new Audio('sonidos/efectos/pifia.mp3');

      const controlMentalSound = new Audio('sonidos/efectos/controlMental.mp3');
      const curarSound = new Audio('sonidos/efectos/curar.mp3');
      const explosionSound = new Audio('sonidos/efectos/explosion.mp3');
      const incapacitarSound = new Audio('sonidos/efectos/incapacitar.wav');
      const pulsoSound = new Audio('sonidos/efectos/pulso.wav');
      
      let pendingPopupSound = null;
      const BOARD_ROWS = 10;
      const BOARD_COLS = 16;
      const backgroundMusic = new Audio('sonidos/sintonias/Endgame.mp3');
      backgroundMusic.loop = true;
      backgroundMusic.volume = 0.35;

      const introMusic = new Audio('sonidos/sintonias/introduccion.wav');
      introMusic.loop = true; // Para que se repita si tardas mucho en elegir
      introMusic.volume = 0.4; // Ajusta el volumen si quieres

      let backgroundStarted = false;
      let isPlayerVsAI = false;
      let gameStarted = false;
      const PROBABILIDAD_DURATION = 2;
      const SUPPORT_POWERS = new Set([
        'probabilidad',
        'mejora de ataque',
        'mejora de defensa',
        'mejora de agilidad',
        'mejora de critico',
        'curar',
      ]);
      let draftOrder = [];
      let draftIndex = 0;
      let firstPicker = 'player1';
      let draftActive = false;
      const selections = { player1: [], player2: [] };
      let availableCharacters = [];

    function revealModes() {
      startScreen.classList.add('start-screen--modes');
      playButton.hidden = true;
      playButton.style.display = 'none';
      playButton.setAttribute('aria-hidden', 'true');
      modeSelection.hidden = false;
      modeSelection.removeAttribute('hidden');
      modeSelection.style.display = 'grid';
    }

    function hideStartScreen() {
      startScreen.classList.add('start-screen--hidden');
      startScreen.setAttribute('aria-hidden', 'true');
      startScreen.hidden = true;
      startScreen.style.display = 'none';
    }

      playButton.addEventListener('click', () => {
        revealModes();
      });

      let initialPositions = [];

      const ALLY_COLORS = ['piece--white', 'piece--red', 'piece--violet', 'piece--blue', 'piece--gold'];
      const ENEMY_COLORS = ['piece--black', 'piece--violet', 'piece--red', 'piece--blue', 'piece--gold'];

    function generateSlots(count, { startCol, direction, palette }) {
      const slots = [];
      let col = startCol;
      let colorIndex = 0;

      while (slots.length < count && col >= 1 && col <= BOARD_COLS) {
        for (let row = 1; row <= BOARD_ROWS && slots.length < count; row += 1) {
          const className = palette[colorIndex % palette.length];
          slots.push({ row, col, className });
          colorIndex += 1;
        }
        col += direction;
      }

      return slots;
    }

    function createPieceElement({ key, team, className }) {
    const stats = pieceStats[key];
    const piece = document.createElement('span');
    piece.className = `piece ${className}`;
    piece.dataset.team = team;
    piece.dataset.key = key;
    piece.setAttribute('role', 'img');
    piece.setAttribute('aria-label', stats?.name || key);
    piece.innerHTML = `
        <img class="piece__image" src="${stats?.imagen || ''}" alt="${stats?.name || key}" />
        <span class="piece__name">${stats?.name || key}</span>
    `;

    // --- AÑADE ESTA LÍNEA AQUÍ ---
    attachTooltipEvents(piece); 
    // -----------------------------

    return piece;
}

    function buildBoard() {
      board.innerHTML = '';
      for (let row = 1; row <= BOARD_ROWS; row += 1) {
        for (let col = 1; col <= BOARD_COLS; col += 1) {
          const square = document.createElement('div');
          square.className = 'square';
          const occupant = initialPositions.find((item) => item.row === row && item.col === col);
          if (occupant) {
            square.appendChild(createPieceElement(occupant));
          }
          board.appendChild(square);
        }
      }
      squares = Array.from(board.querySelectorAll('.square'));
      squaresByCoord = new Map();
      squares.forEach((square, index) => {
        const row = Math.floor(index / BOARD_COLS) + 1;
        const col = (index % BOARD_COLS) + 1;
        square.dataset.row = row;
        square.dataset.col = col;
        squaresByCoord.set(`${row},${col}`, square);
      });
    }

    let squares = [];
    const tooltip = document.getElementById('tooltip');
    const turnPopup = document.getElementById('turnPopup');
    const turnPopupMessage = document.getElementById('turnPopupMessage');
    const deathPopup = document.getElementById('deathPopup');
    const deathPopupMessage = document.getElementById('deathPopupMessage');
    const allyPanel = document.getElementById('allyPanel');
    const enemyPanel = document.getElementById('enemyPanel');
    const passButton = document.getElementById('passTurn');
    const attackButton = document.getElementById('attack');
    const powerControls = document.getElementById('powerControls');
    const turnInfo = document.getElementById('turnInfo');
    const movementInfo = document.getElementById('movementInfo');
    const allyCards = document.getElementById('allyCards');
    const enemyCards = document.getElementById('enemyCards');

    const AI_DELAY_MS = 900;
    const TURN_DELAY_MS = 250;
    const ENEMY_ACTION_DELAY_MS = 500;
    const DEFAULT_MOVE_DURATION_MS = 1200;

    let squaresByCoord = new Map();
    const pieceMap = new Map();
    let movementDistances = new Map();
    let currentAction = 'attack';
    let movementAnimationDuration = DEFAULT_MOVE_DURATION_MS;
    const movementPool = new Map();
    let turnOrder = [];
    let turnIndex = 0;

    // --- FUNCIONES DE MOVIMIENTO (RECUPERADAS) ---
    function remainingMovement(piece) {
      return movementPool.get(piece) ?? Number(piece.dataset.movimiento);
    }

    function resetMovement(piece) {
      movementPool.set(piece, Number(piece.dataset.movimiento));
    }

    function spendMovement(piece, amount) {
      const left = Math.max(remainingMovement(piece) - amount, 0);
      movementPool.set(piece, left);
    }
    // ---------------------------------------------

    function recomputeTurnOrder() {
      turnOrder = pieces
        .map(({ element }) => element)
        .filter(Boolean)
        .sort((a, b) => {
          const statsA = pieceMap.get(a);
          const statsB = pieceMap.get(b);
          if (statsA.agilidad === statsB.agilidad) {
            return Math.random() < 0.5 ? -1 : 1;
          }
          return statsB.agilidad - statsA.agilidad;
        });
      turnIndex = 0;
    }

    function normalizePowerKey(power) {
      return power
        ?.toString()
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '');
    }

    function hasPassive(stats, key) {
      const search = normalizePowerKey(key);
      const list = stats?.poderes?.pasivos || [];
      return list.map((entry) => normalizePowerKey(entry?.nombre ?? entry)).includes(search);
    }

    function hasActive(stats, key) {
      const search = normalizePowerKey(key);
      const list = stats?.poderes?.activos || [];
      return list.map((entry) => normalizePowerKey(entry?.nombre ?? entry)).includes(search);
    }

    function pieceColor(element) {
      if (element.classList.contains('piece--white')) return '#dcdcdc';
      if (element.classList.contains('piece--red')) return '#c62828';
      if (element.classList.contains('piece--violet')) return '#8e44ad';
      if (element.classList.contains('piece--blue')) return '#1e88e5';
      if (element.classList.contains('piece--gold')) return '#f4a300';
      return '#1f1f1f';
    }

    function addPoints(piece, amount) {
      const stats = pieceMap.get(piece);
      if (!stats || !Number.isFinite(amount)) return;
      stats.puntos = (stats.puntos || 0) + amount;
    }

    function isEnemy(attacker, target) {
      return attacker?.dataset.team && target?.dataset.team && attacker.dataset.team !== target.dataset.team;
    }

function registerTurnSound({ damageDealt = 0, attackFailed = false, zeroDamageHit = false } = {}) {
      if (damageDealt > 0) {
        pendingPopupSound = 'punch';
      } else if (zeroDamageHit) {
        pendingPopupSound = 'oh'; // <--- Sonido para acierto con 0 daño
      } else if (attackFailed && !pendingPopupSound) {
        pendingPopupSound = 'failure';
      }
    }

    function playTurnSound() {
      const chosen = pendingPopupSound;
      pendingPopupSound = null;
      
      let sound = null;
      if (chosen === 'punch') sound = punchSound;
      else if (chosen === 'failure') sound = failureSound;
      else if (chosen === 'oh') sound = ohSound; // <--- Reproducimos el OH
      
      if (!sound) return;
      sound.currentTime = 0;
      sound.play().catch(() => {});
    }

    function playEffectSound(sound) {
      if (!sound) return;
      sound.currentTime = 0;
      sound.play().catch(() => {});
    }

    function startBackgroundMusic() {
      if (backgroundStarted) return;
      backgroundStarted = true;
      backgroundMusic.currentTime = 0;
      backgroundMusic.play().catch(() => {
        backgroundStarted = false;
      });
    }

    function attachPieceData(piece, key, team) {
      const stats = pieceStats[key];
      if (!stats) return;

      // --- LISTA DE PODERES OCULTOS ---
      // Los ponemos en minúsculas. El juego ignorará cualquier poder que esté aquí.
      const HIDDEN_POWERS = [
          'barrera', 
          'telekinesis' // Añado esta variante por si acaso en el futuro lo escribes con 'q'
      ];
      // --------------------------------

      const rawPowers = stats.poderes || { activos: [], pasivos: [] };

      // Filtramos las listas eliminando los que estén en la lista negra
      const filteredPowers = {
          activos: (rawPowers.activos || []).filter(p => {
              const nombre = normalizePowerKey(p.nombre || p);
              return !HIDDEN_POWERS.includes(nombre);
          }),
          pasivos: (rawPowers.pasivos || []).filter(p => {
              const nombre = normalizePowerKey(p.nombre || p);
              return !HIDDEN_POWERS.includes(nombre);
          })
      };

      // Resto de la lógica de inicialización (sin cambios)
      const baseDamage = stats.dano ?? 0;
      const baseResistencia = 0; 

      const computedStats = {
        ...stats,
        dano: baseDamage,
        resistencia: baseResistencia,
        poderes: filteredPowers, // <--- USAMOS LA LISTA FILTRADA
        baseAtaque: stats.ataque,
        baseDefensa: stats.defensa,
        baseAgilidad: stats.agilidad,
        statBuffs: {},
        currentVida: stats.vida,
        maxVida: stats.vida,
        incapacitatedTurns: 0,
        probabilidadTurns: 0,
        puntos: 0,
      };
      
      piece.dataset.key = key;
      piece.dataset.team = team;
      piece.dataset.rango = stats.rango;
      piece.dataset.movimiento = stats.movimiento;
      piece.dataset.stats = JSON.stringify(computedStats);
      pieceMap.set(piece, computedStats);
    }

    let pieces = [];

    function hydratePieces() {
      pieces = Array.from(board.querySelectorAll('.piece')).map((element) => ({
        element,
        key: element.dataset.key,
        team: element.dataset.team,
      }));

      pieceMap.clear();
      movementPool.clear();

      pieces.forEach(({ element, key, team }) => {
        if (element) {
          attachPieceData(element, key, team);
        }
      });
    }

    function renderLifeCards() {
      allyCards.innerHTML = '';
      enemyCards.innerHTML = '';

      pieces.forEach(({ element }) => {
        if (!element) return;
        const stats = pieceMap.get(element);
        const eliminated = element.dataset.eliminated === 'true';
        const container = element.dataset.team === 'aliado' ? allyCards : enemyCards;
        const card = document.createElement('div');
        card.className = `life-card${eliminated ? ' life-card--eliminated' : ''}`;
        card.innerHTML = `
          <div class="life-card__main">
            <img class="life-card__avatar" src="${stats.imagen}" alt="${stats.name}" loading="lazy" />
            <span class="life-card__label">${stats.name}</span>
            <span class="life-card__meta">Vida: ${Math.max(stats.currentVida, 0)} · ${stats.puntos ?? 0} pts</span>
          </div>
        `;
        container.appendChild(card);
      });
    }

    function rebuildGameState() {
      buildBoard();
      hydratePieces();
      movementDistances = new Map();
      recomputeTurnOrder();
      renderLifeCards();
    }

    const ANIMATION_OVERRIDES = {
      antorcha: 'animaciones/antorcha-humana.webp',
      avispa: 'animaciones/avispa.webp',
      bruja: 'animaciones/bruja-escarlata.webp',
      'bruja-escarlata': 'animaciones/bruja-escarlata.webp',
      capitan: 'animaciones/capitan-america.webp',
      cosa: 'animaciones/la-cosa.webp',
      duende: 'animaciones/duende.webp',
      hulk: 'animaciones/hulk.webp',
      hulka: 'animaciones/hulka.webp',
      'iron-man': 'animaciones/iron-man.webp',
      lobezno: 'animaciones/lobezno.webp',
      spider: 'animaciones/spider-man.webp',
      thor: 'animaciones/thor.webp',
      ciclope: 'animaciones/ciclope.webp',
    };

    function animationImageForPiece(piece, stats) {
      const key = piece?.dataset?.key || '';
      if (key && ANIMATION_OVERRIDES[key]) {
        return ANIMATION_OVERRIDES[key];
      }
      const candidate = key ? `animaciones/${key}.webp` : null;
      return stats?.animacion || stats?.imagen || candidate || '';
    }

    function snapshotCharacter(piece, role) {
      if (!piece) return null;
      const stats = pieceMap.get(piece);
      if (!stats) return null;
      return {
        key: piece.dataset.key,
        team: piece.dataset.team,
        role,
        name: stats.name,
        vida: Math.max(stats.currentVida ?? stats.vida ?? 0, 0),
        puntos: stats.puntos ?? 0,
        imagen: animationImageForPiece(piece, stats),
        eliminated: piece.dataset.eliminated === 'true',
      };
    }

    function setLatestPopupContext(message, participants = []) {
      const context = { message: message || '', allies: [], enemies: [] };
      participants.forEach(({ piece, role }) => {
        const snapshot = snapshotCharacter(piece, role);
        if (!snapshot) return;
        if (snapshot.team === 'aliado') {
          context.allies.push(snapshot);
        } else {
          context.enemies.push(snapshot);
        }
      });
      latestPopupContext = context;
    }

    function renderDuelSide(container, characters) {
      container.innerHTML = '';
      if (!characters || characters.length === 0) {
        container.classList.add('duel-panel--hidden');
        container.style.setProperty('--duel-slot-count', 0);
        return;
      }

      container.classList.remove('duel-panel--hidden');
      container.style.setProperty('--duel-slot-count', characters.length);

      characters.forEach((char) => {
        const card = document.createElement('div');
        card.className = 'duel-card';
        if (char.eliminated) {
          card.classList.add('duel-card--eliminated');
        }
        card.style.flexBasis = `${100 / characters.length}%`;
        
        // --- CAMBIO EN EL CÁLCULO DE LA FUENTE ---
        // Si hay 1 carta: Grande (3.5vw)
        // Si hay 4 cartas: Pequeño (1.4vw)
        let fontSizeBase = 4.5 / Math.sqrt(characters.length); 
        // Límites de seguridad (mínimo 14px visuales aprox, máximo 40px)
        const nameSizeVw = Math.min(3.5, Math.max(1.1, fontSizeBase));
        
        card.style.setProperty('--duel-name-size', `${nameSizeVw}vw`);
        // -----------------------------------------

        const overlayClass = char.role === 'attacker' ? 'duel-card__overlay--attacker' : 'duel-card__overlay--defender';
        card.innerHTML = `
          <img class="duel-card__image" src="${char.imagen}" alt="${char.name}" />
          <div class="duel-card__overlay ${overlayClass}"></div>
          <div class="duel-card__label">
            <p class="duel-card__name">${char.name}</p>
            <p class="duel-card__stats">
              <span class="duel-card__badge">Vida ${char.vida}</span>
              <span class="duel-card__badge">${char.puntos} pts</span>
            </p>
          </div>
        `;
        container.appendChild(card);
      });
    }

    function renderPopupPanels(context) {
      const allies = context?.allies || [];
      const enemies = context?.enemies || [];
      renderDuelSide(allyPanel, allies);
      renderDuelSide(enemyPanel, enemies);
    }

    function fallbackPopupContext(message) {
      const active = turnOrder[turnIndex];
      if (!active) {
        return { message: message || '', allies: [], enemies: [] };
      }
      const snapshot = snapshotCharacter(active, 'attacker');
      if (!snapshot) {
        return { message: message || '', allies: [], enemies: [] };
      }
      const isAlly = snapshot.team === 'aliado';
      return {
        message: message || '',
        allies: isAlly ? [snapshot] : [],
        enemies: isAlly ? [] : [snapshot],
      };
    }

    function addHistoryEntry(team, message, options = {}) {
      const { preserveLatest = false, attacker = null, defenders = [] } = options;
      if (!preserveLatest) {
        latestActionMessage = message;
      }
      if (attacker || defenders.length) {
        const participants = [];
        const seenPieces = new Set();
        if (attacker && !seenPieces.has(attacker)) {
          participants.push({ piece: attacker, role: 'attacker' });
          seenPieces.add(attacker);
        }
        defenders.forEach((target) => {
          if (seenPieces.has(target)) return;
          participants.push({ piece: target, role: 'defender' });
          seenPieces.add(target);
        });
        setLatestPopupContext(message, participants);
      }
    }

    function hideTurnPopup() {
      turnPopup.hidden = true;
    }

    function showTurnPopup(message) {
      return new Promise((resolve) => {
        resolveTurnPopup = () => {
          hideTurnPopup();
          resolve();
        };
        const context = latestPopupContext || fallbackPopupContext(message);
        const finalMessage = context?.message || message || 'Turno completado.';
        turnPopupMessage.textContent = finalMessage;
        renderPopupPanels(context);
        latestPopupContext = null;
        turnPopup.hidden = false;
        playTurnSound();
      });
    }

    function hideDeathPopup() {
      deathPopup.hidden = true;
    }

    function showDeathPopup(message) {
      return new Promise((resolve) => {
        resolveDeathPopup = () => {
          hideDeathPopup();
          resolve();
        };
        deathPopupMessage.textContent = message || 'Un personaje ha caído.';
        deathPopup.hidden = false;
      });
    }

    function handleTurnPopupDismiss() {
      if (turnPopup.hidden || !resolveTurnPopup) return;
      playTurnSound();
      const resolver = resolveTurnPopup;
      resolveTurnPopup = null;
      resolver();
    }

    function handleDeathPopupDismiss() {
      if (deathPopup.hidden || !resolveDeathPopup) return;
      const resolver = resolveDeathPopup;
      resolveDeathPopup = null;
      resolver();
    }

    function handleGlobalDismiss() {
      handleDeathPopupDismiss();
      handleTurnPopupDismiss();
    }

    ['keydown', 'mousedown', 'mouseup', 'touchstart'].forEach((eventName) => {
      document.addEventListener(eventName, (event) => {
        handleGlobalDismiss(event);
      });
    });

    function isSupportPower(actionKey) {
      return SUPPORT_POWERS.has(normalizePowerKey(actionKey));
    }

    function renderPowerButtons(piece) {
      powerControls.innerHTML = '';
      const stats = pieceMap.get(piece);
      if (!stats) return;
      const actives = stats.poderes?.activos || [];
      actives.forEach((ability) => {
        const key = normalizePowerKey(ability?.nombre ?? ability);
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'button';
        const labels = {
          incapacitar: 'Incapacitar',
          explosion: 'Explosión',
          pulso: 'Pulso',
          probabilidad: 'Probabilidad',
          'mejora de ataque': 'Mejora de Ataque',
          'mejora de defensa': 'Mejora de Defensa',
          'mejora de agilidad': 'Mejora de Agilidad',
          'mejora de critico': 'Mejora de Crítico',
          curar: 'Curar',
        };
        btn.textContent = labels[key] || ability?.nombre || ability;
        btn.disabled = false;
        btn.addEventListener('click', () => handleActionClick(key));
        powerControls.appendChild(btn);
      });
    }

    let selectedTarget = null;
    let pendingAttackInfo = null;
    let latestActionMessage = null;
    let latestPopupContext = null;
    let resolveTurnPopup = null;
    let resolveDeathPopup = null;
    const pendingDeathMessages = [];

    function getPieceSquare(piece) {
      return piece.closest('.square');
    }

    function getSquareAt(row, col) {
      return squaresByCoord.get(`${row},${col}`);
    }

    function computeReachableSquares(piece) {
      const origin = getPieceSquare(piece);
      if (!origin) return;
      const stats = pieceMap.get(piece);
      const canPhase = hasPassive(stats, 'fase');
      const maxMove = remainingMovement(piece);
      const visited = new Map();
      const queue = [{ row: Number(origin.dataset.row), col: Number(origin.dataset.col), cost: 0 }];
      visited.set(`${origin.dataset.row},${origin.dataset.col}`, 0);

      const deltas = [
        [1, 0],
        [-1, 0],
        [0, 1],
        [0, -1],
      ];

      while (queue.length) {
        const { row, col, cost } = queue.shift();
        for (const [dr, dc] of deltas) {
          const nr = row + dr;
          const nc = col + dc;
          const key = `${nr},${nc}`;
          if (nr < 1 || nr > BOARD_ROWS || nc < 1 || nc > BOARD_COLS) continue;
          const nextCost = cost + 1;
          if (nextCost > maxMove) continue;
          if (visited.has(key) && visited.get(key) <= nextCost) continue;
          const square = getSquareAt(nr, nc);
          if (!square) continue;
          const occupant = square.querySelector('.piece');
          if (occupant && occupant.dataset.team !== piece.dataset.team && !canPhase) continue;
          visited.set(key, nextCost);
          queue.push({ row: nr, col: nc, cost: nextCost });
        }
      }

      movementDistances = new Map();
      visited.forEach((dist, key) => {
        const square = squaresByCoord.get(key);
        if (!square) return;
        const occupied = square.querySelector('.piece');
        if (!occupied && dist > 0) {
          movementDistances.set(square, dist);
        }
      });
    }

    function clearMoveHighlights() {
      squares.forEach((square) => square.classList.remove('square--move'));
    }

    function clearRangeHighlights() {
      squares.forEach((square) => square.classList.remove('square--range', 'square--target'));
    }

    function clearHighlights() {
      clearMoveHighlights();
      clearRangeHighlights();
      tooltip.hidden = true;
      selectedTarget = null;
    }

    function highlightMovement(piece) {
      computeReachableSquares(piece);
      if (movementDistances.size === 0) return;
      movementDistances.forEach((_, square) => {
        square.classList.add('square--move');
      });
    }

    function isWithinAttackRange(attackerSquare, targetSquare, maxRange, { includeOrigin = false } = {}) {
      const attackerRow = Number(attackerSquare.dataset.row);
      const attackerCol = Number(attackerSquare.dataset.col);
      const targetRow = Number(targetSquare.dataset.row);
      const targetCol = Number(targetSquare.dataset.col);
      const distance = Math.abs(targetRow - attackerRow) + Math.abs(targetCol - attackerCol);
      return distance <= maxRange && (includeOrigin ? distance >= 0 : distance > 0);
    }

    function highlightRange(piece) {
      clearRangeHighlights();
      const origin = getPieceSquare(piece);
      if (!origin) return;
      const maxRange = rangeForPiece(piece);
      if (maxRange <= 0) return;
      squares.forEach((square) => {
        if (isWithinAttackRange(origin, square, maxRange)) {
          square.classList.add('square--range');
        }
      });
    }

    function setActivePiece(piece) {
      document.querySelectorAll('.piece').forEach((p) => p.classList.remove('piece--active'));
      piece.classList.add('piece--active');
      passButton.disabled = false;
      attackButton.disabled = false;
      updateStatusBar(piece);
      updateCombatInfo();
      currentAction = 'attack';
      renderPowerButtons(piece);
    }

    function updateStatusBar(piece) {
      const stats = pieceMap.get(piece);
      if (!stats) return;
      turnInfo.textContent = `Turno: ${stats.name}`;
      movementInfo.textContent = `Movimiento restante: ${remainingMovement(piece)}`;
    }

    function attackDistance(attackerSquare, targetSquare) {
      return (
        Math.abs(Number(attackerSquare.dataset.row) - Number(targetSquare.dataset.row)) +
        Math.abs(Number(attackerSquare.dataset.col) - Number(targetSquare.dataset.col))
      );
    }

    function effectiveRangeFromStats(stats) {
      const raw = Number(stats?.rango ?? 0);
      return raw === 0 ? 1 : raw;
    }

    function calculateDamage(attackerStats, defenderStats, distance, isCritical) {
      const isMelee = distance <= 1;
      
      // 1. Obtenemos el daño base inicial
      let baseDamageBeforeClaws = attackerStats.dano ?? 0;

      // --- NUEVO: IMPLEMENTACIÓN DE EXPERTO A/D ---
      // Si el ataque es a distancia (no es melee) y tiene el poder, sumamos 2 al base.
      if (!isMelee && hasPassive(attackerStats, 'experto a/d')) {
        baseDamageBeforeClaws += 2;
      }
      // --------------------------------------------
      
      // 2. Lógica de Garras (Solo melee)
      let clawsRoll = null;
      const hasClaws = isMelee && hasPassive(attackerStats, 'garras'); 
      if (hasClaws) {
        clawsRoll = Math.floor(Math.random() * 6) + 1;
      }
      
      // Si tiene garras, el daño base es el mayor entre el actual y la tirada
      const baseDamageAfterClaws = hasClaws
        ? Math.max(baseDamageBeforeClaws, clawsRoll)
        : baseDamageBeforeClaws;
      
      // 3. Cálculo de Crítico (x2)
      const baseDamageWithCrit = isCritical ? baseDamageAfterClaws * 2 : baseDamageAfterClaws;
      
      // 4. Cálculo de Resistencia (Dureza / Invulnerable)
      let valDureza = 0;
      let valInvulnerable = 0;
      let valInvulnerableAD = 0;

      if (hasPassive(defenderStats, 'dureza')) valDureza = 1;
      if (hasPassive(defenderStats, 'invulnerable')) valInvulnerable = 2;
      if (!isMelee && hasPassive(defenderStats, 'invulnerable a/d')) valInvulnerableAD = 2;
      
      // Nos quedamos con la mayor resistencia
      const resistance = Math.max(valDureza, valInvulnerable, valInvulnerableAD);
      
      // 5. Daño Final
      const totalDamage = Math.max(baseDamageWithCrit - resistance, 0);
      
      return {
        totalDamage,
        isMelee,
        clawsRoll,
        rawDamage: baseDamageWithCrit,
        resistance,
        baseDamageBeforeClaws, // Ahora este valor incluirá el +2 de Experto a/d si aplica
        baseDamageAfterClaws,
      };
    }

    function evaluateAttackRoll(attackerStats, defenderStats, roll, distance, options = {}) {
      const { allowCounter = false } = options;
      const critical = isCriticalRoll(attackerStats, roll);
      const isPifia = roll === 2;
      const isMelee = distance <= 1;
      const defenderCanRanged = effectiveRangeFromStats(defenderStats) > 1;

      let success = false;

      if (critical) {
        success = true;
      } else if (isPifia) {
        if (isMelee || defenderCanRanged) {
          success = roll + attackerStats.ataque >= defenderStats.defensa;
        } else {
          success = false;
        }
      } else {
        success = roll + attackerStats.ataque >= defenderStats.defensa;
      }

      const shouldCounter = allowCounter && isPifia && (isMelee || defenderCanRanged);

      return { success, critical, isPifia, shouldCounter };
    }

    function hasProbabilidad(stats) {
      return Number(stats?.probabilidadTurns ?? 0) > 0;
    }

    function isCriticalRoll(attackerStats, roll) {
      if (!roll) return false;
      const hasAstucia = hasPassive(attackerStats, 'astucia');
      const empowered = hasProbabilidad(attackerStats);
      const critBuff = Boolean(attackerStats?.critBuff);
      if ((empowered && hasAstucia) || (critBuff && (empowered || hasAstucia))) return roll >= 10;
      if (empowered || hasAstucia || critBuff) return roll >= 11;
      return roll === 12;
    }

    function queueDeathMessage(message) {
      pendingDeathMessages.push(message);
    }

    async function showQueuedDeathPopups() {
      while (pendingDeathMessages.length > 0) {
        const message = pendingDeathMessages.shift();
        // eslint-disable-next-line no-await-in-loop
        await showDeathPopup(message);
      }
    }

    function eliminatePiece(piece) {
      if (!piece || piece.dataset.eliminated === 'true') return;
      playEffectSound(deathSound);
      const index = turnOrder.indexOf(piece);
      if (index !== -1) {
        turnOrder.splice(index, 1);
        if (index <= turnIndex && turnIndex > 0) {
          turnIndex -= 1;
        }
      }
      piece.dataset.eliminated = 'true';
      piece.remove();
    }

    function rangeForPiece(piece) {
      const r = parseInt(piece.dataset.rango, 10);
      return r === 0 ? 1 : r;
    }

    // Variable global para controlar el tiempo (ponla justo antes de las funciones)
let tooltipTimer = null;

function showTooltip(piece) {
  const stats = pieceMap.get(piece);
  if (!stats) return;

  // --- 1. ETIQUETA DE EQUIPO ---
  let teamLabel = piece.dataset.team || '';
  if (teamLabel) {
      teamLabel = teamLabel.charAt(0).toUpperCase() + teamLabel.slice(1);
      teamLabel = `(${teamLabel})`;
  }

  // --- 2. LISTAS DE PODERES ---
  const activos = (stats.poderes?.activos || []).map(p => p.nombre || p).join('</li><li>');
  const pasivos = (stats.poderes?.pasivos || []).map(p => p.nombre || p).join('</li><li>');

  // --- 3. RECOPILACIÓN DE BUFFOS (EL ARREGLO ESTÁ AQUÍ) ---
  let listaBuffos = [];

  // A) Buffos de estadísticas (Ataque, Defensa, Agilidad)
  if (stats.statBuffs) {
      Object.values(stats.statBuffs).forEach(v => listaBuffos.push(v.label));
  }

  // B) Buffo de Crítico (se guardaba aparte y por eso no salía)
  if (stats.critBuff) {
      listaBuffos.push(stats.critBuff.label);
  }
  
  // C) Probabilidad (si quieres que salga también como efecto positivo)
  if (stats.probabilidadTurns > 0) {
      listaBuffos.push("Probabilidad");
  }

  const buffosTexto = listaBuffos.join(', ');
  // ---------------------------------------------------------

  tooltip.innerHTML = `
    <h3>${stats.name} <span style="font-size:0.8em; opacity:0.7">${teamLabel}</span></h3>
    
    <ul>
      <li><strong>Vida:</strong> ${Math.max(stats.currentVida, 0)} / ${stats.maxVida}</li>
      <li><strong>Movimiento:</strong> ${stats.movimiento}</li>
      <li><strong>Ataque:</strong> ${stats.ataque} <small>(Base: ${stats.baseAtaque || stats.ataque})</small></li>
      <li><strong>Defensa:</strong> ${stats.defensa} <small>(Base: ${stats.baseDefensa || stats.defensa})</small></li>
      <li><strong>Agilidad:</strong> ${stats.agilidad} <small>(Base: ${stats.baseAgilidad || stats.agilidad})</small></li>
      <li><strong>Daño:</strong> ${stats.dano}</li>
      <li><strong>Rango:</strong> ${stats.rango}</li>
    </ul>

    <div>
        ${activos ? `<h4>Poderes Activos</h4><ul class="power-list"><li>${activos}</li></ul>` : ''}
        ${pasivos ? `<h4>Poderes Pasivos</h4><ul class="power-list"><li>${pasivos}</li></ul>` : ''}
    </div>
    
    ${buffosTexto ? `<h4 style="color:#4ade80">Buffos Temporales</h4><div style="font-size:0.8rem; margin-left:10px;">${buffosTexto}</div>` : ''}
  `;

  tooltip.hidden = false;
  requestAnimationFrame(() => positionTooltip(piece));
}


function hideTooltip() {
  tooltip.hidden = true;
  if (tooltipTimer) {
    clearTimeout(tooltipTimer);
    tooltipTimer = null;
  }
}

function attachTooltipEvents(piece) {
  // Usamos pointerenter/leave que funcionan mejor para ratón y touch
  piece.addEventListener('pointerenter', () => {
    // Si es la pieza activa o del mismo equipo, normalmente no mostramos info
    // PERO como es para debug, lo mostramos igual. Si quieres ocultarlo en turno propio, descomenta abajo:
    /* const activePiece = turnOrder[turnIndex];
    if (piece === activePiece) return; 
    */
    
    // Limpiamos cualquier timer anterior
    if (tooltipTimer) clearTimeout(tooltipTimer);

    // Esperamos 1 segundo (1000ms) antes de mostrar
    tooltipTimer = setTimeout(() => {
      showTooltip(piece);
    }, 1000);
  });

  piece.addEventListener('pointerleave', () => {
    hideTooltip();
  });
  
  // Ocultar también al hacer clic para que no moleste al atacar
  piece.addEventListener('click', () => {
    hideTooltip();
  });
}

    function positionTooltip(target) {
      const targetRect = target.getBoundingClientRect();
      const tooltipRect = tooltip.getBoundingClientRect();
      const offset = 12;
      const padding = 8;
      let left = targetRect.right + offset;
      let top = targetRect.top + targetRect.height / 2 - tooltipRect.height / 2;

      if (left + tooltipRect.width > window.innerWidth - padding) {
        left = targetRect.left - tooltipRect.width - offset;
      }

      left = Math.max(padding, Math.min(left, window.innerWidth - tooltipRect.width - padding));
      top = Math.max(padding, Math.min(top, window.innerHeight - tooltipRect.height - padding));

      tooltip.style.left = `${left}px`;
      tooltip.style.top = `${top}px`;
    }


    function setIncapacitated(piece, turns = 1) {
      const stats = pieceMap.get(piece);
      if (!stats) return;
      stats.incapacitatedTurns = turns;
      piece.classList.add('piece--incapacitated');
    }

    function actionLabel(actionKey) {
      if (actionKey === 'incapacitar') return 'Incapacitar';
      if (actionKey === 'explosion') return 'Explosión';
      if (actionKey === 'pulso') return 'Pulso';
      if (actionKey === 'probabilidad') return 'Probabilidad';
      if (actionKey === 'mejora de ataque') return 'Mejora de Ataque';
      if (actionKey === 'mejora de defensa') return 'Mejora de Defensa';
      if (actionKey === 'mejora de agilidad') return 'Mejora de Agilidad';
      if (actionKey === 'mejora de critico') return 'Mejora de Crítico';
      if (actionKey === 'curar') return 'Curar';
      return 'Ataque';
    }

    function neededRollToHit(attackerStats, defenderStats) {
      if (!attackerStats || !defenderStats) return 0;
      const delta = defenderStats.defensa - attackerStats.ataque;
      return Math.max(4, delta);
    }

      function buildAttackPopupMessage({
        attackerStats,
        defenderStats,
        roll,
        success,
        damage,
        isMelee,
        resistance,
        rawDamage,
        actionKey,
        clawsRoll,
        critical,
        baseDamageBeforeClaws,
        baseDamageAfterClaws,
      }) {
        const need = neededRollToHit(attackerStats, defenderStats);
        
        // --- BLOQUE PERSONALIZADO: INCAPACITAR ---
        if (actionKey === 'incapacitar') {
          const opening = `${attackerStats.name} realiza un ataque de Incapacitación con ${attackerStats.ataque} a ${defenderStats.name} que defiende con ${defenderStats.defensa}.`;
          const rollLine = `${attackerStats.name} necesita un ${need} y ${roll ? `consigue un ${roll}.` : 'prepara la tirada.'}`;
          const resultLine = success
            ? `${attackerStats.name} incapacita a ${defenderStats.name}.`
            : `${attackerStats.name} falla el ataque contra ${defenderStats.name}.`;
          return `${opening} ${rollLine} ${resultLine}`;
        }

        // --- BLOQUE PERSONALIZADO: CONTROL MENTAL ---
        if (actionKey === 'control mental') {
            const opening = `${attackerStats.name} realiza un ataque de Control Mental con ${attackerStats.ataque} a ${defenderStats.name} que defiende con ${defenderStats.defensa}.`;
            const rollLine = `${attackerStats.name} necesita un ${need} y ${roll ? `consigue un ${roll}.` : 'prepara la tirada.'}`;
            
            let resultLine = '';
            if (success) {
                resultLine = `${defenderStats.name} es controlado y pasa al equipo de ${attackerStats.name} este turno.`;
            } else {
                resultLine = `${attackerStats.name} falla el ataque de Control Mental contra ${defenderStats.name}.`;
            }
            
            return `${opening} ${rollLine} ${resultLine}`;
        }
        // ---------------------------------------------

        // --- ATAQUES NORMALES (Daño) ---
        const attackTypeLabel = isMelee ? 'ataque cuerpo a cuerpo' : 'ataque a distancia';
        const resistanceLabel = 'resistencia';
        const baseDamage = rawDamage ?? damage;
        const inflictedDamage = success ? damage : 0;

        const opening = `${attackerStats.name} realiza un ${attackTypeLabel} con ${attackerStats.ataque} a ${defenderStats.name} que defiende con ${defenderStats.defensa}.`;
        const rollLine = `${attackerStats.name} necesita un ${need} y ${roll ? `consigue un ${roll}${critical ? ' (Crítico)' : ''}.` : 'prepara la tirada.'}`;

        if (!success) {
          return `${opening} ${rollLine} ${attackerStats.name} falla el ataque contra ${defenderStats.name}.`;
        }

        const clawsLine =
          clawsRoll !== null && clawsRoll !== undefined
            ? `${attackerStats.name} hace una tirada de garras y consigue ${clawsRoll}, con lo que su daño base ${
                clawsRoll > baseDamageBeforeClaws ? 'aumenta a' : 'se mantiene en'
              } ${clawsRoll > baseDamageBeforeClaws ? baseDamageAfterClaws : baseDamageBeforeClaws}.`
            : '';
        
        const baseDamageLine =
          clawsRoll === null || clawsRoll === undefined
            ? `El daño base del ataque es ${baseDamage}.`
            : '';
            
        const resistanceLine = `${defenderStats.name} tiene una ${resistanceLabel} de ${resistance ?? 0}.`;
        const damageLine = `${attackerStats.name} le causa ${inflictedDamage} puntos de daño infligido a ${defenderStats.name}.`;
        const deathLine = defenderStats.currentVida <= 0 ? `${defenderStats.name} es eliminado.` : '';

      return `${opening} ${rollLine} ${clawsLine} ${baseDamageLine} ${resistanceLine} ${damageLine} ${deathLine}`.replace(/\s+/g, ' ').trim();
    }
    function updateCombatInfo() {
      const combatBox = document.getElementById('combatInfo');
      if (!combatBox) {
        return;
      }
      if (!pendingAttackInfo) {
        combatBox.textContent = '';
        return;
      }
      const info = pendingAttackInfo;
      if (info.targets) {
        const summary = info.targets
          .map((target) => {
            const base = `${target.name}: ${target.success ? 'Éxito' : 'Fallo'}`;
            const damageText = target.success ? ` | Daño ${target.damage} (Vida ${target.vida})` : '';
            return `${base}${damageText}`;
          })
          .join(' | ');
        combatBox.textContent = `${info.action} de ${info.attackerName} | Tirada 2d6: ${info.roll}${
          info.critical ? ' (Crítico)' : ''
        } | ${summary}`;
        return;
      }
      let rollText = info.roll ? ` | Tirada 2d6: ${info.roll}` : '';
      let successText = '';
      if (info.roll) {
        successText = info.success ? (info.critical ? ' (Crítico)' : ' (Éxito)') : ' (Fallo)';
      }
      const damageText = info.roll ? ` | Daño: ${info.damage} | Vida defensor: ${info.defenderVida}` : '';
      const clawsText = info.clawsRoll ? ` | Garras d6: ${info.clawsRoll}` : '';
      const noteText = info.note ? ` | ${info.note}` : '';
      combatBox.textContent = `${info.action} ${info.attackerName} (${info.attacker}) vs ${info.defenderName} (${info.defender}) | Diferencia: ${info.difference}${rollText}${successText}${damageText}${clawsText}${noteText}`;
    }

    function prepareAttackInfo(attacker, defender, actionKey = 'attack') {
      const attackerStats = pieceMap.get(attacker);
      const defenderStats = pieceMap.get(defender);
      pendingAttackInfo = {
        action: actionLabel(actionKey),
        attacker: attackerStats.ataque,
        defender: defenderStats.defensa,
        difference: attackerStats.ataque - defenderStats.defensa,
        roll: null,
        success: null,
        critical: false,
        damage: 0,
        defenderVida: defenderStats.currentVida,
        attackerName: attackerStats.name,
        defenderName: defenderStats.name,
        clawsRoll: null,
        note: null,
      };
      attackButton.classList.add('button--pulse');
      updateCombatInfo();
    }
    

async function resolveAttack(attacker, defender, actionKey = 'attack', options = {}) {
      const { 
        allowCounter = true, 
        skipTurnAdvance = false, 
        actionLabelOverride = null, 
        isSecondAttack = false 
      } = options;

      const attackerStats = pieceMap.get(attacker);
      const defenderStats = pieceMap.get(defender);
      const attackerSquare = getPieceSquare(attacker);
      const targetSquare = getPieceSquare(defender);
      const distance = attackDistance(attackerSquare, targetSquare);

      // --- 1. CÁLCULOS ---
      const die1 = Math.floor(Math.random() * 6) + 1;
      const die2 = Math.floor(Math.random() * 6) + 1;
      const roll = die1 + die2;
      
      const { success, critical, isPifia, shouldCounter } = evaluateAttackRoll(
        attackerStats, defenderStats, roll, distance, { allowCounter }
      );

      // SONIDOS
      if (critical) playEffectSound(criticoSound);
      if (isPifia) playEffectSound(pifiaSound);

      const { totalDamage, clawsRoll, isMelee, resistance, rawDamage, baseDamageBeforeClaws, baseDamageAfterClaws } = 
        calculateDamage(attackerStats, defenderStats, distance, critical);

      const isStatusAttack = actionKey === 'incapacitar' || actionKey === 'control mental';
      const damageApplied = success && !isStatusAttack ? totalDamage : 0;

      // --- 2. APLICAR EFECTOS ---
      let specialEffectMessage = ''; // Se queda vacío, el mensaje ahora lo genera buildAttackPopupMessage

      if (success) {
        if (actionKey === 'incapacitar') {
          setIncapacitated(defender, 1);
          if (isEnemy(attacker, defender)) addPoints(attacker, SCORE_PER_DAMAGE);
          playEffectSound(incapacitarSound);
        } 
        else if (actionKey === 'control mental') {
          const currentTeam = defender.dataset.team;
          defenderStats.originalTeam = currentTeam; 
          
          const newTeam = currentTeam === 'aliado' ? 'enemigo' : 'aliado';
          
          defenderStats.team = newTeam;
          defender.dataset.team = newTeam;
          defenderStats.mindControlled = true;
          
          // ELIMINADO: specialEffectMessage = `...` (Ya no hace falta)
          playEffectSound(controlMentalSound);
        }
        else if (damageApplied > 0) {
          defenderStats.currentVida = Math.max(defenderStats.currentVida - damageApplied, 0);
          if (isEnemy(attacker, defender)) addPoints(attacker, damageApplied * SCORE_PER_DAMAGE);

          if (hasPassive(attackerStats, 'robo de vida')) {
            const missing = attackerStats.maxVida - attackerStats.currentVida;
            const heal = Math.min(damageApplied, missing);
            if (heal > 0) {
              attackerStats.currentVida += heal;
              specialEffectMessage = ` ${attackerStats.name} roba vida (+${heal}).`;
            }
          }
        }
      }

      // --- 3. PREPARAR MENSAJE ---
      const labelAccion = actionLabelOverride || (isSecondAttack ? '2º Ataque c/c' : actionLabel(actionKey));

      let popupMessage = buildAttackPopupMessage({
        attackerStats, defenderStats, roll, success, damage: damageApplied,
        isMelee, resistance, rawDamage, actionKey, clawsRoll, critical,
        baseDamageBeforeClaws, baseDamageAfterClaws
      });
      
      popupMessage += specialEffectMessage; // Solo añade robo de vida si aplica

      addHistoryEntry(attacker.dataset.team, popupMessage, { attacker, defenders: [defender] });

      if (success && !isStatusAttack && defenderStats.currentVida <= 0) {
        queueDeathMessage(`${defenderStats.name} eliminado por ${attackerStats.name}.`);
        if (isEnemy(attacker, defender)) addPoints(attacker, SCORE_PER_KILL);
        eliminatePiece(defender);
      }

      // Sonido Normal
      const skipFailureSound = isPifia; 
      const isZeroDamageHit = success && damageApplied === 0 && !isStatusAttack;
      
      registerTurnSound({ 
        damageDealt: damageApplied, 
        attackFailed: !success && !skipFailureSound, 
        zeroDamageHit: isZeroDamageHit 
      });

      if (damageApplied > 0 && !pendingPopupSound) pendingPopupSound = 'punch';

      renderLifeCards();
      updateCombatInfo();

      // --- 4. FLUJO DE PIFIA Y DOBLE ATAQUE ---
      if (shouldCounter && defenderStats.currentVida > 0 && defender.dataset.eliminated !== 'true') {
        await showTurnPopup(`¡PIFIA! ${attackerStats.name} ha fallado estrepitosamente.\n${defenderStats.name} prepara su contraataque.\n(Haz clic para resolver la réplica)`);
        await sleep(300);
        await resolveAttack(defender, attacker, 'attack', {
          allowCounter: false,
          skipTurnAdvance: true,
          actionLabelOverride: 'Réplica',
        });
        if (!skipTurnAdvance) finishTurn(attacker);
        return;
      }

      const hasDoubleAttack = hasPassive(attackerStats, 'doble ataque c/c');
      if (isMelee && hasDoubleAttack && !isSecondAttack && !options.actionLabelOverride && !isStatusAttack &&
          defenderStats.currentVida > 0 && defender.dataset.eliminated !== 'true' &&
          attackerStats.currentVida > 0 && attacker.dataset.eliminated !== 'true') {
        
        await showTurnPopup(`${popupMessage}\n\n[DOBLE ATAQUE]\n(Clic para el segundo golpe)`);
        await sleep(300);
        await resolveAttack(attacker, defender, actionKey, {
          ...options,
          isSecondAttack: true, 
          actionLabelOverride: '2º Ataque c/c'
        });
        return; 
      }

      if (!skipTurnAdvance) {
        hideTooltip();
        clearRangeHighlights();
        selectedTarget = null;
        attackButton.classList.remove('button--pulse');
        finishTurn(attacker);
      }
    }
    

   async function resolveExplosion(attacker, defender) {
      const attackerStats = pieceMap.get(attacker);
      const attackerSquare = getPieceSquare(attacker);
      const centerSquare = getPieceSquare(defender);
      
      const die1 = Math.floor(Math.random() * 6) + 1;
      const die2 = Math.floor(Math.random() * 6) + 1;
      const roll = die1 + die2;
      const critical = isCriticalRoll(attackerStats, roll);

      if (critical) playEffectSound(criticoSound);
      
      // --- 1. MENSAJE AJUSTADO (Daño Base) ---
      let baseRaw = attackerStats.dano ?? 0;
      if (critical) baseRaw *= 2; // Mostramos el base YA multiplicado si es crítico
      const damageDescription = `${attackerStats.name} tiene un daño base para este ataque de ${baseRaw}`;
      // ---------------------------------------

      const affectedPieces = [];
      const seenPieces = new Set();
      let totalDamageDealt = 0;
      let anySuccess = false;

      const CROSS_OFFSETS = [[0, 0], [1, 0], [-1, 0], [0, 1], [0, -1]];

      CROSS_OFFSETS.forEach(([dr, dc]) => {
        const row = Number(centerSquare.dataset.row) + dr;
        const col = Number(centerSquare.dataset.col) + dc;
        const square = getSquareAt(row, col);
        if (!square) return;
        const piece = square.querySelector('.piece');
        if (!piece || seenPieces.has(piece)) return;
        seenPieces.add(piece);
        affectedPieces.push({ piece, square });
      });

      const targetsSummary = [];

      affectedPieces.forEach(({ piece, square }) => {
        const targetStats = pieceMap.get(piece);
        const distanceToAttacker = attackDistance(attackerSquare, square);
        
        // Bloqueamos contraataque con allowCounter: false
        const { success } = evaluateAttackRoll(attackerStats, targetStats, roll, distanceToAttacker, {
          allowCounter: false, 
        });

        let damage = 0;
        if (success) {
          // Usamos el baseRaw calculado arriba
          let valDureza = 0;
          let valInvulnerable = 0;
          let valInvulnerableAD = 0;

          if (hasPassive(targetStats, 'dureza')) valDureza = 1;
          if (hasPassive(targetStats, 'invulnerable')) valInvulnerable = 2;
          if (distanceToAttacker > 1 && hasPassive(targetStats, 'invulnerable a a/d')) {
              valInvulnerableAD = 2;
          }

          const resistance = Math.max(valDureza, valInvulnerable, valInvulnerableAD);
          damage = Math.max(baseRaw - resistance, 0);
          
          targetStats.currentVida = Math.max(targetStats.currentVida - damage, 0);
          totalDamageDealt += damage;
          if (isEnemy(attacker, piece)) addPoints(attacker, damage * SCORE_PER_DAMAGE);
          anySuccess = true;
        }

        const eliminated = success && targetStats.currentVida <= 0;
        targetsSummary.push({ name: targetStats.name, success, damage, eliminated });

        if (eliminated) {
          queueDeathMessage(`${targetStats.name} ha sido eliminado por ${attackerStats.name}.`);
          if (isEnemy(attacker, piece)) addPoints(attacker, SCORE_PER_KILL);
          eliminatePiece(piece);
        }
      });

      // Formato de lista
      const formatter = new Intl.ListFormat('es', { style: 'long', type: 'conjunction' });
      const detailsList = targetsSummary.map(t => {
        if (!t.success) return `${t.name} (esquiva)`;
        let detail = `daño ${t.damage}`; // Ya no mostramos "daño recibido", solo "daño X"
        if (t.eliminated) detail += ` y eliminado`;
        return `${t.name} (${detail})`;
      });

      const affectedText = detailsList.length > 0 ? formatter.format(detailsList) : 'Ninguno';
      
      // Construcción exacta del mensaje solicitado
      const logMessage = `${attackerStats.name} ejecuta Explosión. Ataca con ${attackerStats.ataque} y consigue en la tirada un ${roll}. ${damageDescription}. Afectados: ${affectedText}.`;

      pendingAttackInfo = {
        action: actionLabel('explosion'),
        attackerName: attackerStats.name,
        roll,
        critical,
        targets: targetsSummary,
      };

      playEffectSound(explosionSound);
      addHistoryEntry(attacker.dataset.team, logMessage, { attacker, defenders: affectedPieces.map(({ piece }) => piece) });
      registerTurnSound({ damageDealt: totalDamageDealt, attackFailed: !anySuccess });
      renderLifeCards();
      hideTooltip();
      clearRangeHighlights();
      selectedTarget = null;
      attackButton.classList.remove('button--pulse');
      updateCombatInfo();
      
      await showTurnPopup(logMessage);
      finishTurn(attacker, { showPopup: false });
    }
    

   async function resolvePulse(attacker) { // Nota: Hazla async para ser consistente
      const attackerStats = pieceMap.get(attacker);
      const attackerSquare = getPieceSquare(attacker);
      
      const die1 = Math.floor(Math.random() * 6) + 1;
      const die2 = Math.floor(Math.random() * 6) + 1;
      const roll = die1 + die2;
      const critical = isCriticalRoll(attackerStats, roll);
      
      if (critical) playEffectSound(criticoSound);

      // --- 1. MENSAJE AJUSTADO ---
      let baseRaw = attackerStats.dano ?? 0;
      if (critical) baseRaw *= 2;
      const damageDescription = `${attackerStats.name} tiene un daño base para este ataque de ${baseRaw}`;
      // ---------------------------

      const attackTotal = attackerStats.ataque + roll;
      const affectedPieces = [];
      let totalDamageDealt = 0;
      const CROSS_OFFSETS = [[1, 0], [-1, 0], [0, 1], [0, -1]];

      CROSS_OFFSETS.forEach(([dr, dc]) => {
        const row = Number(attackerSquare.dataset.row) + dr;
        const col = Number(attackerSquare.dataset.col) + dc;
        const square = getSquareAt(row, col);
        const occupant = square?.querySelector('.piece');
        if (!occupant) return;
        affectedPieces.push({ piece: occupant, square, distance: 1 });
      });

      const targetsSummary = [];
      let anySuccess = false;

      affectedPieces.forEach(({ piece, distance }) => {
        const targetStats = pieceMap.get(piece);
        const success = attackTotal >= targetStats.defensa;

        let damage = 0;
        if (success) {
          // Mitigación (Pulso es distancia 1, a/d no aplica normalmente pero dejamos la lógica)
          let valDureza = 0;
          let valInvulnerable = 0;
          let valInvulnerableAD = 0;

          if (hasPassive(targetStats, 'dureza')) valDureza = 1;
          if (hasPassive(targetStats, 'invulnerable')) valInvulnerable = 2;
          if (distance > 1 && hasPassive(targetStats, 'invulnerable a a/d')) {
              valInvulnerableAD = 2;
          }
          const resistance = Math.max(valDureza, valInvulnerable, valInvulnerableAD);
          
          damage = Math.max(baseRaw - resistance, 0);
          
          if (damage > 0) {
            targetStats.currentVida = Math.max(targetStats.currentVida - damage, 0);
            totalDamageDealt += damage;
            if (isEnemy(attacker, piece)) addPoints(attacker, damage * SCORE_PER_DAMAGE);
          }
          anySuccess = true;
        }

        targetsSummary.push({
          name: targetStats.name,
          success,
          damage,
          eliminated: success && targetStats.currentVida <= 0
        });

        if (success && targetStats.currentVida <= 0) {
          queueDeathMessage(`${targetStats.name} ha sido eliminado por el Pulso de ${attackerStats.name}.`);
          if (isEnemy(attacker, piece)) addPoints(attacker, SCORE_PER_KILL);
          eliminatePiece(piece);
        }
      });

      // Formato de lista
      const formatter = new Intl.ListFormat('es', { style: 'long', type: 'conjunction' });
      const detailsList = targetsSummary.map(t => {
        if (!t.success) return `${t.name} (esquiva)`;
        let detail = `daño ${t.damage}`;
        if (t.eliminated) detail += ` y eliminado`;
        return `${t.name} (${detail})`;
      });

      const affectedText = detailsList.length > 0 ? formatter.format(detailsList) : 'Ninguno';

      // Mensaje final ajustado
      const logMessage = `${attackerStats.name} ejecuta Pulso. Ataca con ${attackerStats.ataque} y consigue en la tirada un ${roll}. ${damageDescription}. Afectados: ${affectedText}.`;

      pendingAttackInfo = {
        action: actionLabel('pulso'),
        attackerName: attackerStats.name,
        roll: roll,
        critical: critical,
        targets: targetsSummary,
      };

      playEffectSound(pulsoSound);
      addHistoryEntry(attacker.dataset.team, logMessage, { attacker, defenders: affectedPieces.map(({ piece }) => piece) });

      registerTurnSound({ damageDealt: totalDamageDealt, attackFailed: !anySuccess });

      renderLifeCards();
      hideTooltip();
      clearRangeHighlights();
      selectedTarget = null;
      attackButton.classList.remove('button--pulse');
      updateCombatInfo();
      
      // Hacemos await para que se vea el mensaje
      if (affectedPieces.length > 0 || anySuccess) {
         await showTurnPopup(logMessage);
      }
      
      finishTurn(attacker, { showPopup: false }); // Ya mostramos el popup arriba
    }



    function alliedPiecesInRange1(centerSquare, team) {
      if (!centerSquare) return [];

      // Definimos "Adyacentes" como la CRUZ (más el centro)
      const offsets = [
        [0, 0],   // Centro (Objetivo principal)
        [1, 0],   // Abajo
        [-1, 0],  // Arriba
        [0, 1],   // Derecha
        [0, -1],  // Izquierda
      ];

      const allies = [];
      const seenPieces = new Set();

      offsets.forEach(([dr, dc]) => {
        const row = Number(centerSquare.dataset.row) + dr;
        const col = Number(centerSquare.dataset.col) + dc;
        const square = getSquareAt(row, col);
        
        if (square) {
          const occupant = square.querySelector('.piece');
          // Debe haber pieza, no estar repetida y ser del MISMO equipo
          if (occupant && !seenPieces.has(occupant) && occupant.dataset.team === team) {
            seenPieces.add(occupant);
            allies.push(occupant);
          }
        }
      });

      return allies;
    }

    function applyProbabilidad(attacker, target) {
      const attackerStats = pieceMap.get(attacker);
      const centerSquare = getPieceSquare(target);
      if (!attackerStats || !centerSquare) return;

      const affected = alliedPiecesInRange1(centerSquare, attacker.dataset.team).map((piece) => {
        const stats = pieceMap.get(piece);
        if (!stats) return null;
        stats.probabilidadTurns = PROBABILIDAD_DURATION;
        return { piece, stats };
      });

      const validAffected = affected.filter(Boolean);

      const recipientNames = validAffected.map(({ stats }) => stats.name).join(', ');
      if (validAffected.length > 0) {
        addPoints(attacker, validAffected.length * 10);
        renderLifeCards();
      }
      const message = validAffected.length
        ? `${attackerStats.name} aplica Probabilidad sobre ${recipientNames}.`
        : `${attackerStats.name} intenta aplicar Probabilidad, pero nadie se beneficia.`;

      addHistoryEntry(attacker.dataset.team, message, {
        attacker,
        defenders: validAffected.map(({ piece }) => piece),
      });

      pendingAttackInfo = {
        action: actionLabel('probabilidad'),
        attackerName: attackerStats.name,
        roll: '-',
        targets: validAffected.map(({ stats }) => ({
          name: stats.name,
          success: true,
          damage: 0,
          vida: stats.currentVida,
        })),
      };

      hideTooltip();
      clearRangeHighlights();
      clearTargetSelection(true);
      attackButton.classList.remove('button--pulse');
      updateCombatInfo();
      finishTurn(attacker);
    }

   function applyStatBuff(attacker, target, { stat, label }) {
      const attackerStats = pieceMap.get(attacker);
      const centerSquare = getPieceSquare(target);
      if (!attackerStats || !centerSquare) return;

      // 1. Identificar objetivos (Centro + Cruz)
      const affected = alliedPiecesInRange1(centerSquare, attacker.dataset.team).map((piece) => {
        const stats = pieceMap.get(piece);
        if (!stats) return null;
        
        // --- A) MEJORA DE CRÍTICO ---
        if (stat === 'critico') {
          // Activamos el flag 'critBuff'. La función isCriticalRoll ya sabe que:
          // - Si tiene buff y NO tiene Astucia pasiva -> Crítico con 11+
          // - Si tiene buff Y SI tiene Astucia pasiva -> Crítico con 10+
          stats.critBuff = { remaining: 2, label };
          return { piece, stats };
        }

        // --- B) MEJORAS DE ESTADÍSTICAS (Ataque, Defensa, Agilidad) ---
        // Definimos qué propiedad base mirar y cuánto sumar
        const configMap = {
            'ataque': { baseKey: 'baseAtaque', boost: 1 },
            'defensa': { baseKey: 'baseDefensa', boost: 1 },
            'agilidad': { baseKey: 'baseAgilidad', boost: 10 }
        };

        const config = configMap[stat];
        if (config) {
            // Aseguramos que existe el valor base original
            if (stats[config.baseKey] === undefined) {
                stats[config.baseKey] = stats[stat];
            }
            
            // Regla: El valor es SIEMPRE Base + Boost (No se acumula, solo se fija)
            stats[stat] = stats[config.baseKey] + config.boost;
            
            // Guardamos el buff para contar los turnos
            stats.statBuffs = stats.statBuffs || {};
            stats.statBuffs[stat] = { 
                remaining: 2, 
                label, 
                baseValue: stats[config.baseKey] // Guardamos base para restaurar luego
            };
        }
        
        return { piece, stats };
      });

      const validAffected = affected.filter(Boolean);
      const recipientNames = validAffected.map(({ stats }) => stats.name).join(', ');

      // --- 2. PUNTOS (+10 por personaje afectado) ---
      if (validAffected.length > 0) {
        const pointsEarned = validAffected.length * 10;
        addPoints(attacker, pointsEarned);
        
        // Usamos sonido de curar (o efecto positivo)
        if (typeof curarSound !== 'undefined') playEffectSound(curarSound);
        else playEffectSound(incapacitarSound); 
      }

      // --- 3. MENSAJES E HISTORIAL ---
      const message = validAffected.length
        ? `${attackerStats.name} aplica ${label} sobre: ${recipientNames}.`
        : `${attackerStats.name} intenta aplicar ${label}, pero nadie se beneficia.`;

      addHistoryEntry(attacker.dataset.team, message, {
        attacker,
        defenders: validAffected.map(({ piece }) => piece), // Los tratamos visualmente como defenders para el log
      });

      pendingAttackInfo = {
        action: label,
        attackerName: attackerStats.name,
        roll: '-',
        targets: validAffected.map(({ stats }) => ({
          name: stats.name,
          success: true, // Siempre es éxito si es aliado
          damage: 0,
          vida: stats.currentVida,
        })),
      };

      // --- 4. CIERRE VISUAL ---
      renderLifeCards();
      hideTooltip();
      clearRangeHighlights();
      clearTargetSelection(true);
      attackButton.classList.remove('button--pulse');
      updateCombatInfo();
      
      // Mostramos popup informativo
      showTurnPopup(message).then(() => {
          finishTurn(attacker, { showPopup: false });
      });
    }

async function resolveHeal(attacker, target) {
      const attackerStats = pieceMap.get(attacker);
      const targetStats = pieceMap.get(target);
      if (!attackerStats || !targetStats) return;

      // 1. Calculamos "Daño Recibido" (Max - Actual)
      const damageReceived = Math.max(targetStats.maxVida - targetStats.currentVida, 0);

      // Si el objetivo está a tope de vida, no se puede curar
      if (damageReceived === 0) {
        await showTurnPopup(`${attackerStats.name} intenta curar a ${targetStats.name}, pero ya está al máximo de salud.`);
        hideTooltip();
        clearTargetSelection(true);
        finishTurn(attacker, { showPopup: false });
        return;
      }

      // 2. Tirada: Ataque + Daño Recibido + 2d6
      const die1 = Math.floor(Math.random() * 6) + 1;
      const die2 = Math.floor(Math.random() * 6) + 1;
      const roll = die1 + die2;
      
      const attackValue = attackerStats.ataque + damageReceived + roll;
      const difficulty = targetStats.defensa;
      
      const success = attackValue >= difficulty;

      let healed = 0;
      let healRoll = 0;
      let resultMessage = "";

      if (success) {
        // 3. Éxito: Tiramos 1d6 para ver cuánto cura
        healRoll = Math.floor(Math.random() * 6) + 1;
        // Nunca puede curar más de lo que le falta (Daño Recibido)
        healed = Math.min(healRoll, damageReceived);
        
        targetStats.currentVida += healed;
        addPoints(attacker, healed * 5); // Damos puntos por curar

        resultMessage = `¡Éxito! Recupera ${healed} puntos de vida (Tirada cura: ${healRoll}).`;
        // Efecto visual/sonoro
        playEffectSound(curarSound); // Usamos un sonido genérico de efecto
      } else {
        resultMessage = "Fallo. No consigue aplicar la cura.";
        registerTurnSound({ attackFailed: true }); // Sonido de fallo
      }

      // 4. Construimos el mensaje detallado
      const details = `Ataque (${attackerStats.ataque}) + Heridas (${damageReceived}) + Dados (${roll}) = ${attackValue}.\nDificultad (Defensa): ${difficulty}.`;
      const finalMessage = `${attackerStats.name} intenta curar a ${targetStats.name}.\n${details}\n\n${resultMessage}`;

      // Historial
      addHistoryEntry(attacker.dataset.team, finalMessage, { attacker, defenders: [target] });

      // 5. Actualizamos UI y mostramos Popup
      renderLifeCards();
      hideTooltip();
      clearRangeHighlights();
      clearTargetSelection(true);
      attackButton.classList.remove('button--pulse');
      updateCombatInfo();

      await showTurnPopup(finalMessage);
      
      finishTurn(attacker, { showPopup: false });
    }

    function clearTargetSelection(preserveAttack = false) {
      squares.forEach((square) => square.classList.remove('square--target'));
      selectedTarget = null;
      if (!preserveAttack) {
        pendingAttackInfo = null;
      }
      attackButton.classList.remove('button--pulse');
      hideTooltip();
      updateCombatInfo();
      if (turnOrder.length > 0) {
        highlightRange(turnOrder[turnIndex]);
      }
    }

    board.addEventListener('click', async (event) => {
      // Si no hay piezas o turno activo, no hacemos nada
      if (turnOrder.length === 0) return;

      const activePiece = turnOrder[turnIndex];
      const square = event.target.closest('.square');
      if (!square) return;

      const targetPiece = square.querySelector('.piece');

      // --- A) LÓGICA DE SELECCIÓN DE OBJETIVO (Click en personaje) ---
      if (targetPiece) {
        const isSamePiece = targetPiece === activePiece;
        const isAllyTarget = targetPiece.dataset.team === activePiece.dataset.team;

        // Determinamos si la acción actual busca aliados o enemigos
        const supportAction = isSupportPower(currentAction);

        if (supportAction) {
          if (!isAllyTarget) return; // Poder de ayuda: solo a aliados
        } else {
          if (isAllyTarget || isSamePiece) return; // Ataque: solo a enemigos
        }

        // Comprobamos rango
        const attackerSquare = getPieceSquare(activePiece);
        const maxRange = rangeForPiece(activePiece);
        const includeOrigin = supportAction;

        if (!isWithinAttackRange(attackerSquare, square, maxRange, { includeOrigin })) {
          if (typeof showTurnPopup === 'function') showTurnPopup('El objetivo está fuera de rango.');
          else alert('El objetivo está fuera de rango.');
          
          clearTargetSelection();
          return;
        }

        // Marcamos el objetivo
        clearTargetSelection();
        square.classList.add('square--target');
        selectedTarget = targetPiece;

        // Actualizamos información visual
        const attackerStats = pieceMap.get(activePiece);
        const targetStats = pieceMap.get(targetPiece);
        
        pendingAttackInfo = {
          action: actionLabel(currentAction),
          attackerName: attackerStats?.name,
          defenderName: targetStats?.name,
          note: supportAction ? 'Aliado seleccionado' : 'Objetivo seleccionado',
        };
        updateCombatInfo();
        attackButton.classList.add('button--pulse');
        return;
      }

      // --- B) LÓGICA DE MOVIMIENTO (Click en cuadro vacío) ---
      // Si tiene la clase 'square--move', es válido para mover
      if (square.classList.contains('square--move')) {
        // Doble comprobación de seguridad
        if (square.querySelector('.piece')) return;

        const distance = movementDistances.get(square);

        // Verificamos que la distancia esté calculada y tengamos movimiento
        if (distance !== undefined && distance <= remainingMovement(activePiece)) {
          // 1. Ejecutamos la animación de movimiento
          await animatePieceToSquare(activePiece, square);
          
          // 2. Restamos el movimiento gastado
          spendMovement(activePiece, distance);
          
          // 3. Limpiamos y recalculamos luces (rango y nuevo movimiento posible)
          clearHighlights();
          highlightMovement(activePiece);
          highlightRange(activePiece);
          updateStatusBar(activePiece);
        }
        return;
      }
    });

function handleActionClick(actionKey) {
      currentAction = actionKey;
      const attacker = turnOrder[turnIndex];
      
      // 1. Acciones sin objetivo (Área)
      if (actionKey === 'pulso') {
        resolvePulse(attacker);
        return;
      }

      // 2. Verificaciones básicas de objetivo
      if (!selectedTarget) {
        const supportAction = isSupportPower(actionKey);
        alert(supportAction ? 'Selecciona primero un aliado dentro de tu rango.' : 'Selecciona primero un enemigo dentro de tu rango.');
        return;
      }

      const attackerSquare = getPieceSquare(attacker);
      const targetSquare = getPieceSquare(selectedTarget);
      const maxRange = rangeForPiece(attacker);
      const includeOrigin = isSupportPower(actionKey);

      if (!isWithinAttackRange(attackerSquare, targetSquare, maxRange, { includeOrigin })) {
        alert('El objetivo está fuera de rango.');
        clearTargetSelection();
        return;
      }

      const supportAction = normalizePowerKey(actionKey);

      // 3. Poderes de Apoyo
      if (supportAction === 'probabilidad') {
        applyProbabilidad(attacker, selectedTarget);
        return;
      }
      if (supportAction === 'mejora de ataque') {
        applyStatBuff(attacker, selectedTarget, { stat: 'ataque', label: 'Mejora de Ataque' });
        return;
      }
      if (supportAction === 'mejora de defensa') {
        applyStatBuff(attacker, selectedTarget, { stat: 'defensa', label: 'Mejora de Defensa' });
        return;
      }
      if (supportAction === 'mejora de agilidad') {
        applyStatBuff(attacker, selectedTarget, { stat: 'agilidad', label: 'Mejora de Agilidad' });
        return;
      }
      if (supportAction === 'mejora de critico') {
        applyStatBuff(attacker, selectedTarget, { stat: 'critico', label: 'Mejora de Crítico' });
        return;
      }
      if (supportAction === 'curar') {
        resolveHeal(attacker, selectedTarget);
        return;
      }

      // --- 4. NUEVO: Lógica de Incapacitar ---
      if (actionKey === 'incapacitar') {
        const targetStats = pieceMap.get(selectedTarget);
        if (targetStats.incapacitatedTurns > 0) {
           if (typeof showTurnPopup === 'function') showTurnPopup(`¡${targetStats.name} ya está incapacitado!`);
           else alert(`¡${targetStats.name} ya está incapacitado!`);
           return;
        }
        // CAMBIO: Añadido allowCounter: false
        resolveAttack(attacker, selectedTarget, 'incapacitar', { allowCounter: false });
        return;
      }

      if (actionKey === 'control mental') {
        const targetStats = pieceMap.get(selectedTarget);
        // Evitamos controlar a alguien que ya está controlado para no liar el código
        if (targetStats.mindControlled) {
            showTurnPopup(`¡${targetStats.name} ya está bajo control mental!`);
            return;
        }
        resolveAttack(attacker, selectedTarget, 'control mental');
        return;
      }
      // ---------------------------------------

      // 5. Resto de Ataques (Explosión y Normal)
      prepareAttackInfo(attacker, selectedTarget, actionKey);
      
      if (actionKey === 'explosion') {
        resolveExplosion(attacker, selectedTarget);
      } else {
        resolveAttack(attacker, selectedTarget, actionKey);
      }
    }

    

    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function animatePieceToSquare(piece, square, options = {}) {
      return new Promise((resolve) => {
        const duration = Number(options.duration ?? movementAnimationDuration);
        if (!piece || !square) {
          resolve();
          return;
        }

        if (!Number.isFinite(duration) || duration <= 0) {
          square.appendChild(piece);
          resolve();
          return;
        }

        const startRect = piece.getBoundingClientRect();
        square.appendChild(piece);
        const endRect = piece.getBoundingClientRect();
        const deltaX = startRect.left - endRect.left;
        const deltaY = startRect.top - endRect.top;

        const animation = piece.animate(
          [
            { transform: `translate(-50%, -50%) translate(${deltaX}px, ${deltaY}px)` },
            { transform: 'translate(-50%, -50%)' },
          ],
          {
            duration,
            easing: 'ease-in-out',
          },
        );

        animation.addEventListener('finish', resolve);
        animation.addEventListener('cancel', resolve);
      });
    }

    function findClosestEnemy(piece) {
      const origin = getPieceSquare(piece);
      if (!origin) return null;
      const opponents = pieces
        .map((p) => p.element)
        .filter((p) => p && p.dataset.team === 'aliado' && p.dataset.eliminated !== 'true');
      let best = null;
      let bestDistance = Infinity;
      opponents.forEach((candidate) => {
        const sq = getPieceSquare(candidate);
        if (!sq) return;
        const distance = attackDistance(origin, sq);
        if (distance < bestDistance) {
          bestDistance = distance;
          best = candidate;
        }
      });
      return best;
    }

    function chooseEnemyMoveSquare(piece, targetSquare) {
      computeReachableSquares(piece);
      const origin = getPieceSquare(piece);
      const maxRange = rangeForPiece(piece);
      if (origin && targetSquare && isWithinAttackRange(origin, targetSquare, maxRange)) {
        return null;
      }
      let bestSquare = null;
      let bestDistance = Infinity;
      movementDistances.forEach((_, square) => {
        const distance = attackDistance(square, targetSquare);
        if (distance < bestDistance) {
          bestDistance = distance;
          bestSquare = square;
        }
      });
      return bestSquare;
    }

    function shouldUseIncapacitar(attackerStats, targetStats) {
      if (!attackerStats || !targetStats) return false;
      const targetResilience = targetStats.resistencia ?? 0; // Esto leerá 0 o lo calculado si se pasara, pero para IA simple vale
      const targetThreat = targetStats.ataque ?? 0;
      const targetVida = targetStats.currentVida ?? targetStats.vida ?? 0;
      
      // CAMBIO V2: Simplificar lectura de daño potencial
      const potentialDamage = attackerStats.dano ?? 0;
      
      const canLikelyFinish = targetVida <= potentialDamage + 4;
      const tanky = targetResilience > 0 && targetVida > potentialDamage + 6;
      const veryDangerous = targetThreat >= 11;
      return (tanky || veryDangerous) && !canLikelyFinish;
    }

    function selectBestEnemyAction(piece, targetPiece) {
      const stats = pieceMap.get(piece);
      const abilities = (stats?.poderes?.activos || []).map((entry) => normalizePowerKey(entry?.nombre ?? entry));
      const targetStats = pieceMap.get(targetPiece);
      const targetSquare = getPieceSquare(targetPiece);
      const origin = getPieceSquare(piece);
      const inRange = origin && targetSquare && isWithinAttackRange(origin, targetSquare, rangeForPiece(piece));
      if (!inRange) return 'move';

      if (abilities.includes('explosion')) {
        const deltas = [-1, 0, 1];
        let enemyNeighbors = 0;
        deltas.forEach((dr) => {
          deltas.forEach((dc) => {
            const sq = getSquareAt(Number(targetSquare.dataset.row) + dr, Number(targetSquare.dataset.col) + dc);
            const occupant = sq?.querySelector('.piece');
            if (occupant && occupant !== piece && occupant.dataset.team !== piece.dataset.team) {
              enemyNeighbors += 1;
            }
          });
        });
        if (enemyNeighbors >= 2) {
          return 'explosion';
        }
      }

      if (
        abilities.includes('incapacitar') &&
        targetStats?.incapacitatedTurns === 0 &&
        shouldUseIncapacitar(stats, targetStats)
      ) {
        return 'incapacitar';
      }

      return 'attack';
    }

    async function performEnemyTurn(piece) {
      const target = findClosestEnemy(piece);
      
      // Si no hay enemigos (muy raro), pasa turno con sonido
      if (!target) {
        playEffectSound(passTurnSound); 
        finishTurn(piece);
        return;
      }

      const targetSquare = getPieceSquare(target);
      const chosenAction = selectBestEnemyAction(piece, target);

      if (chosenAction === 'move') {
        const moveSquare = chooseEnemyMoveSquare(piece, targetSquare);
        if (moveSquare) {
          const distance = movementDistances.get(moveSquare) ?? 0;
          clearHighlights();
          highlightMovement(piece);
          moveSquare.classList.add('square--target');
          await sleep(ENEMY_ACTION_DELAY_MS);
          await animatePieceToSquare(piece, moveSquare);
          spendMovement(piece, distance);
          clearHighlights();
          highlightMovement(piece);
          highlightRange(piece);
          updateStatusBar(piece);
        }
      }

      await sleep(ENEMY_ACTION_DELAY_MS);
      const refreshedTarget = findClosestEnemy(piece) || target;
      const action = selectBestEnemyAction(piece, refreshedTarget);
      
      // Si decide moverse otra vez o no atacar, pasa turno con sonido
      if (action === 'move') {
        playEffectSound(passTurnSound); // <--- AÑADIDO SONIDO AQUÍ
        finishTurn(piece);
        return;
      }
      
      selectedTarget = refreshedTarget;
      handleActionClick(action);
    }

    function applyRegeneration(piece) {
      const stats = pieceMap.get(piece);
      if (!stats || !hasPassive(stats, 'regeneracion')) return { regenerated: false, message: '' };
      if (stats.currentVida < stats.maxVida) {
        stats.currentVida = Math.min(stats.currentVida + 1, stats.maxVida);
        renderLifeCards();
        const message = `${stats.name} regenera 1 punto de vida (vida ${stats.currentVida}).`;
        const shouldAttachContext = !latestPopupContext;
        addHistoryEntry(piece.dataset.team, message, {
          preserveLatest: true,
          attacker: shouldAttachContext ? piece : null,
        });
        return { regenerated: true, message };
      }
      return { regenerated: false, message: '' };
    }

    function consumeProbabilidadTurn(piece) {
      const stats = pieceMap.get(piece);
      if (!stats || !stats.probabilidadTurns) return { expired: false, message: '' };
      stats.probabilidadTurns = Math.max(stats.probabilidadTurns - 1, 0);
      if (stats.probabilidadTurns === 0) {
        return { expired: true, message: `${stats.name} pierde Probabilidad.` };
      }
      return { expired: false, message: '' };
    }

    function consumeStatBuffs(piece) {
      const stats = pieceMap.get(piece);
      if (!stats) return [];
      const messages = [];
      if (stats.statBuffs) {
        Object.entries(stats.statBuffs).forEach(([stat, buff]) => {
          buff.remaining -= 1;
          if (buff.remaining <= 0) {
            const baseKey = stat === 'ataque' ? 'baseAtaque' : stat === 'defensa' ? 'baseDefensa' : 'baseAgilidad';
            stats[stat] = stats[baseKey] ?? stats[stat];
            messages.push(`${stats.name} pierde ${buff.label?.toLowerCase?.() || stat}.`);
            delete stats.statBuffs[stat];
          }
        });
      }
      if (stats.critBuff) {
        stats.critBuff.remaining -= 1;
        if (stats.critBuff.remaining <= 0) {
          messages.push(`${stats.name} pierde ${stats.critBuff.label?.toLowerCase?.() || 'mejora de crítico'}.`);
          delete stats.critBuff;
        }
      }
      return messages;
    }

    function advanceTurn() {
      if (turnOrder.length === 0) return;
      turnIndex = (turnIndex + 1) % turnOrder.length;
      const nextPiece = turnOrder[turnIndex];
      const delay = TURN_DELAY_MS;
      setTimeout(() => startTurn(nextPiece), delay);
    }

    async function finishTurn(piece, options = {}) {
      const { skipRegeneration = false, summaryOverride = null, showPopup = null } = options;
      
      const stats = pieceMap.get(piece);
      
      // 1. Regeneración
      const regenResult = skipRegeneration ? { regenerated: false, message: '' } : applyRegeneration(piece);
      
      // 2. Probabilidad
      const probabilityResult = consumeProbabilidadTurn(piece);
      
      // 3. Buffos
      const buffMessages = consumeStatBuffs(piece);

      // --- 4. RECUPERACIÓN DE CONTROL MENTAL (NUEVO) ---
      let mindControlMsg = '';
      if (stats && stats.mindControlled) {
        // Revertimos al equipo original
        stats.team = stats.originalTeam;
        piece.dataset.team = stats.originalTeam; // Devuelve el color original
        
        // Limpiamos las marcas
        stats.mindControlled = false;
        delete stats.originalTeam;
        
        mindControlMsg = ` ${stats.name} se libera del control mental y vuelve a su equipo.`;
      }
      // --------------------------------------------------

      // Construcción del mensaje final
      const summaryParts = [
        summaryOverride || latestActionMessage || (stats ? `${stats.name} finaliza su turno.` : 'Turno completado.'),
      ];
      if (regenResult?.regenerated) summaryParts.push(regenResult.message);
      if (probabilityResult?.expired) summaryParts.push(probabilityResult.message);
      buffMessages.forEach((msg) => summaryParts.push(msg));
      
      if (mindControlMsg) summaryParts.push(mindControlMsg); // Añadimos el mensaje de liberación

      const summary = summaryParts.join(' ').trim();
      latestActionMessage = null;

      if (latestPopupContext) {
        latestPopupContext.message = summary;
      } else if (regenResult?.regenerated || mindControlMsg) {
        setLatestPopupContext(summary, [{ piece, role: piece.dataset.team === 'aliado' ? 'attacker' : 'defender' }]);
      }

      const shouldShowPopup = showPopup ?? Boolean(latestPopupContext);
      if (shouldShowPopup) {
        await showTurnPopup(summary);
      } else {
        latestPopupContext = null;
      }

      if (pendingDeathMessages.length > 0) {
        await showQueuedDeathPopups();
      }

      advanceTurn();
    }

function startTurn(piece) {
      if (!piece) return;
      const stats = pieceMap.get(piece);
      if (!stats) return;

      // 1. Verificar Incapacitado
      if (stats.incapacitatedTurns && stats.incapacitatedTurns > 0) {
        const incapMessage = `${stats.name} pierde el turno por estar incapacitado.`;
        addHistoryEntry(piece.dataset.team, incapMessage, { attacker: piece });
        stats.incapacitatedTurns -= 1;
        if (stats.incapacitatedTurns <= 0) {
          piece.classList.remove('piece--incapacitated');
        }
        renderLifeCards();
        finishTurn(piece, { summaryOverride: incapMessage });
        return;
      }

      // 2. Configuración Estándar (Tu código original)
      // Esto asegura que si eres TÚ quien controla la pieza (incluso por Control Mental), 
      // los botones y luces se enciendan correctamente.
      resetMovement(piece);
      setActivePiece(piece); // Habilita botones Pass/Attack
      clearTargetSelection(true);
      clearHighlights();
      highlightMovement(piece);
      highlightRange(piece);

      // 3. Bloqueo para IA (Solo si NO lo controlas tú)
      // Si usaste Control Mental, el dataset.team será 'aliado', así que este IF fallará 
      // y podrás jugar con el personaje. Si es un enemigo real, entra aquí.
      if (isPlayerVsAI && piece.dataset.team === 'enemigo') {
        passButton.disabled = true;
        attackButton.disabled = true;
        setTimeout(() => performEnemyTurn(piece), 1000);
      }
    }

    // --- EVENTOS DE LOS BOTONES PRINCIPALES ---

    passButton.addEventListener('click', () => {
      const currentPiece = turnOrder[turnIndex];
      playEffectSound(passTurnSound);
      finishTurn(currentPiece, { showPopup: false });
    });

    // ¡ESTA LÍNEA ES CRUCIAL!
    attackButton.addEventListener('click', () => handleActionClick('attack'));



    function ownerLabel(playerId) {
      if (playerId === 'player1') return 'Jugador 1';
      return isPlayerVsAI ? 'IA' : 'Jugador 2';
    }

    function generateDraftOrder(startingPlayer) {
      const other = startingPlayer === 'player1' ? 'player2' : 'player1';
      const order = [startingPlayer];
      let current = other;
      let streak = 0;
      while (order.length < 24) {
        order.push(current);
        streak += 1;
        if (streak === 2) {
          current = current === 'player1' ? 'player2' : 'player1';
          streak = 0;
        }
      }
      return order;
    }

    function availablePool() {
      return availableCharacters.filter((key) => !selections.player1.includes(key) && !selections.player2.includes(key));
    }

    function renderDraftCards() {
      draftGrid.innerHTML = '';
      const ownership = new Map();
      Object.entries(selections).forEach(([playerId, picks]) => {
        picks.forEach((key) => ownership.set(key, playerId));
      });

      availableCharacters.forEach((key) => {
        const stats = pieceStats[key];
        const card = document.createElement('button');
        card.type = 'button';
        card.className = 'draft-card';
        card.innerHTML = `
          <img class="draft-card__image" src="${stats?.imagen || ''}" alt="${stats?.name || key}" loading="lazy" />
          <div class="draft-card__body">
            <p class="draft-card__title">${stats?.name || key}</p>
          </div>
        `;

        if (ownership.has(key)) {
          card.classList.add('draft-card--taken');
          card.dataset.owner = ownerLabel(ownership.get(key));
          card.disabled = true;
        } else {
          card.addEventListener('click', () => handleDraftPick(key));
        }

        draftGrid.appendChild(card);
      });
    }

    function updateDraftLabels() {
      if (draftIndex >= draftOrder.length) {
        finalizeDraft();
        return;
      }

      const pickerId = draftOrder[draftIndex];
      draftPicker.textContent = `Elige: ${ownerLabel(pickerId)}`;
      draftTurn.textContent = `Turno ${draftIndex + 1} de ${draftOrder.length}`;
      draftCounter.textContent = `Jugador 1: ${selections.player1.length}/12 · ${ownerLabel('player2')}: ${selections.player2.length}/12`;
      draftSubtitle.textContent = `Empieza ${ownerLabel(firstPicker)}. Los turnos alternan ${firstPicker === 'player1' ? '1, 2, 2, 1...' : '2, 1, 1, 2...'} hasta llegar a 12 por bando.`;
      const remaining = 12 - selections[pickerId].length;
      draftPrompt.textContent = `${ownerLabel(pickerId)} selecciona (${remaining} plazas restantes en su equipo).`;
      draftInfo.textContent = 'Los personajes elegidos no se pueden repetir. Tras la última elección comenzará la partida.';
    }

    function draftIsComplete() {
      const teamsFull = selections.player1.length === 12 && selections.player2.length === 12;
      const outOfTurns = draftIndex >= draftOrder.length;
      return teamsFull || outOfTurns;
    }

    function handleDraftPick(key) {
      if (!draftActive) return;
      if (draftIndex >= draftOrder.length) {
        finalizeDraft();
        return;
      }

      const pickerId = draftOrder[draftIndex];
      if (!pickerId) return;
      if (!availablePool().includes(key)) return;
      if (selections[pickerId].length >= 12) return;

      selections[pickerId].push(key);
      draftIndex = Math.min(draftIndex + 1, draftOrder.length);
      renderDraftCards();

      if (selections.player1.length === 12 && selections.player2.length === 12) {
        finalizeDraft();
        return;
      }

      if (draftIsComplete()) {
        finalizeDraft();
        return;
      }

      updateDraftLabels();

      const nextPicker = draftOrder[draftIndex];
      if (isPlayerVsAI && nextPicker === 'player2') {
        setTimeout(performAIPick, 600);
      }
    }

    // --- EVALUADOR DE PERSONAJES (PRIORIDAD: DAÑO > VIDA > RANGO) ---
    function evaluateCombatValue(key, stats, enemySelections) {
       
       // 1. CÁLCULO DE VALOR BRUTO
       // Multiplicadores ajustados para que el Daño sea lo más valioso
       let value = 0;

       // PRIORIDAD 1: DAÑO
       // Multiplicamos por 20. Así un personaje con Daño 3 suma 60 puntos solo por eso.
       // Uno con Daño 2 suma 40. La diferencia es enorme.
       value += (stats.dano * 20); 

       // PRIORIDAD 2: VIDA
       // Multiplicamos por 4. Un personaje con 10 de vida suma 40 puntos.
       value += (stats.vida * 4);

       // PRIORIDAD 3: RANGO
       // Multiplicamos por 5. Un personaje a distancia (Rango 3) suma 15 puntos extra.
       value += (stats.rango * 5);

       // DESEMPATES (Muy poco peso, solo para no elegir al azar si empatan en lo importante)
       value += (stats.defensa * 0.5);
       value += (stats.ataque * 0.5);

       // PODERES CLAVE (Solo los que rompen el juego)
       // Aunque prioricemos stats, si alguien cura o incapacita, sigue siendo útil.
       const activePowers = (stats.poderes?.activos || []).map(p => normalizePowerKey(p.nombre || p));
       if (activePowers.includes('incapacitar')) value += 15;
       if (activePowers.includes('curar')) value += 20;


       // 2. LÓGICA DE RESPUESTA (COUNTER PICK SIMPLIFICADO)
       // Solo miramos si el enemigo nos obliga a priorizar aún más esas 3 stats
       if (enemySelections.length > 0) {
           let enemyTankiness = 0;
           let enemyDamage = 0;

           enemySelections.forEach(enemyKey => {
               const est = pieceStats[enemyKey];
               enemyTankiness += est.vida; // Sumamos la vida total del enemigo
               enemyDamage += est.dano;    // Sumamos el daño total del enemigo
           });

           // Si el enemigo tiene mucha Vida en total -> Nuestro DAÑO vale aún más
           if (enemyTankiness > 30) {
               value += (stats.dano * 10); // Bonus extra al daño
           }

           // Si el enemigo pega muy fuerte -> Nuestra VIDA vale aún más
           if (enemyDamage > 10) {
               value += (stats.vida * 2); // Bonus extra a la vida
           }
       }

       return value;
    }

    // --- FUNCIÓN DE SELECCIÓN IA ---
    function performAIPick() {
      if (!draftActive) return;
      if (draftIsComplete() || draftIndex >= draftOrder.length) {
        finalizeDraft();
        return;
      }
      
      const options = availablePool();
      if (options.length === 0) {
        finalizeDraft();
        return;
      }

      const playerSelections = selections.player1;

      // Ordenamos estrictamente por el valor calculado
      options.sort((a, b) => {
          const valA = evaluateCombatValue(a, pieceStats[a], playerSelections);
          const valB = evaluateCombatValue(b, pieceStats[b], playerSelections);
          
          // Reducimos el factor aleatorio al mínimo (casi 0) para que la IA sea "seria"
          // y elija siempre lo que considere matemáticamente mejor.
          return (valB + Math.random()) - (valA + Math.random());
      });

      handleDraftPick(options[0]);
    }

    function buildPositionsFromSelections() {
      const allySlots = generateSlots(selections.player1.length, {
        startCol: 1,
        direction: 1,
        palette: ALLY_COLORS,
      });

      const enemySlots = generateSlots(selections.player2.length, {
        startCol: BOARD_COLS,
        direction: -1,
        palette: ENEMY_COLORS,
      });

      const positions = [];
      selections.player1.forEach((key, idx) => {
        const slot = allySlots[idx];
        if (slot) {
          positions.push({ ...slot, key, team: 'aliado' });
        }
      });
      selections.player2.forEach((key, idx) => {
        const slot = enemySlots[idx];
        if (slot) {
          positions.push({ ...slot, key, team: 'enemigo' });
        }
      });
      return positions;
    }

    function finalizeDraft() {
      draftActive = false;
      initialPositions = buildPositionsFromSelections();
      rebuildGameState();
      draftScreen.hidden = true;
      draftScreen.style.display = 'none';
      draftScreen.style.opacity = '0';
      draftScreen.style.visibility = 'hidden';
      startGame();
    }

    function showDraftScreen() {
      hideStartScreen();
      draftScreen.hidden = false;
      draftScreen.style.display = 'grid';
      draftScreen.style.opacity = '1';
      draftScreen.style.visibility = 'visible';
    }

    function beginDraft(mode) {
      // 1. CORRECCIÓN: Asignamos el modo correctamente
      isPlayerVsAI = (mode === 'ai'); 

      selections.player1 = [];
      selections.player2 = [];
      availableCharacters = Object.keys(pieceStats);
      
      firstPicker = Math.random() < 0.5 ? 'player1' : 'player2';
      draftOrder = generateDraftOrder(firstPicker);
      draftIndex = 0;
      draftActive = true;
      
      showDraftScreen();
      updateDraftLabels();
      renderDraftCards();

      // 2. CORRECCIÓN: Si la IA empieza eligiendo, hay que avisarla
      const currentPicker = draftOrder[draftIndex];
      if (isPlayerVsAI && currentPicker === 'player2') {
        setTimeout(performAIPick, 600);
      }
    }

function startGame() {
      if (gameStarted) return;
      
      // --- AÑADE ESTAS DOS LÍNEAS ---
      introMusic.pause();        // Paramos la intro
      introMusic.currentTime = 0; // La rebobinamos
      // ------------------------------

      gameStarted = true;
      hideStartScreen();
      draftScreen.hidden = true;
      gameContainer.hidden = false;
      startBackgroundMusic(); // Aquí arranca la música de Endgame
      
      if (turnOrder.length > 0) {
        highlightRange(turnOrder[turnIndex]);
        startTurn(turnOrder[turnIndex]);
      }
    }

    function handleModeSelection(mode) {
      if (draftActive || gameStarted) return;
      showDraftScreen();
      beginDraft(mode);
    }

    modeSelection.addEventListener('click', (event) => {
      const button = event.target.closest('[data-mode]');
      if (!button) return;
      handleModeSelection(button.dataset.mode);
    });

    function prepareDefaultSelections() {
      const characters = Object.keys(pieceStats);
      if (characters.length === 0) return false;

      const midpoint = Math.ceil(characters.length / 2);
      selections.player1 = characters.slice(0, midpoint);
      selections.player2 = characters.slice(midpoint);

      initialPositions = buildPositionsFromSelections();
      return initialPositions.length > 0;
    }

   // ... código anterior ...

  /* COMENTAMOS O BORRAMOS LA FUNCIÓN DE SALTAR MENÚS
     startWithoutMenus(); 
  */

  // Y AÑADIMOS ESTO PARA INICIAR NORMALMENTE:
  function initNormalGame() {
      // Configuramos la pantalla visible
      startScreen.hidden = false;
      startScreen.classList.remove('start-screen--hidden');
      startScreen.removeAttribute('hidden');
      startScreen.style.display = 'grid';
      startScreen.style.opacity = '1';
      startScreen.style.visibility = 'visible';

      // --- AÑADE ESTO PARA ARRANCAR LA MÚSICA ---
      introMusic.play().catch(() => {
          // Si el navegador bloquea el autoplay, esperamos al primer clic en cualquier sitio
          console.log("Autoplay bloqueado: esperando interacción del usuario.");
          document.addEventListener('click', () => {
              introMusic.play().catch(() => {});
          }, { once: true });
      });
      // ------------------------------------------
  }

  initNormalGame();
</script>
  </script>
</body>
</html>
